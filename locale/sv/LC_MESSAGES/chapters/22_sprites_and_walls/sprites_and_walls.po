# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Paul Vincent Craven
# This file is distributed under the same license as the Arcade package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Arcade 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-13 15:19-0500\n"
"PO-Revision-Date: 2020-04-03 18:44+0000\n"
"Language-Team: Swedish (https://www.transifex.com/arcade-academy/teams/108729/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:4
msgid "Sprites and Walls"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:7
msgid "Setup"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:9
msgid ""
"Many games with sprites often have \"walls\" that the character can't move "
"through. There are rather straight-forward to create."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:12
msgid ""
"To begin with, let's get a couple images. Our character, and a box that will"
" act as a blocking wall. Both images are from `kenney.nl`_."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:20
msgid ".. image:: chapters/22_sprites_and_walls/images/character.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:20
msgid "images/character.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:25
msgid ".. image:: chapters/22_sprites_and_walls/images/boxCrate_double.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:25
msgid "images/boxCrate_double.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:27
msgid "Start with a default file:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:29
msgid "sprite_move_walls.py start"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:29
msgid ""
"\"\"\" Sprite Sample Program \"\"\"\n"
"\n"
"import arcade\n"
"\n"
"# --- Constants ---\n"
"SPRITE_SCALING_BOX = 0.5\n"
"SPRITE_SCALING_PLAYER = 0.5\n"
"\n"
"SCREEN_WIDTH = 800\n"
"SCREEN_HEIGHT = 600\n"
"\n"
"MOVEMENT_SPEED = 5\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"    \"\"\" This class represents the main window of the game. \"\"\"\n"
"\n"
"    def __init__(self):\n"
"        \"\"\" Initializer \"\"\"\n"
"        # Call the parent class initializer\n"
"        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, \"Sprites With Walls Example\")\n"
"\n"
"\n"
"    def setup(self):\n"
"        # Set the background color\n"
"        arcade.set_background_color(arcade.color.AMAZON)\n"
"\n"
"    def on_draw(self):\n"
"        arcade.start_render()\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame()\n"
"    window.setup()\n"
"    arcade.run()\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:34
msgid ""
"In the ``__init__`` method, let's create some variables to hold our sprites:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:36
msgid ""
"# Sprite lists\n"
"self.player_list = None\n"
"self.wall_list = None\n"
"\n"
"# Set up the player\n"
"self.player_sprite = None\n"
"\n"
"# This variable holds our simple \"physics engine\"\n"
"self.physics_engine = None"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:48
msgid "In the ``setup`` method, let's create our sprite lists:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:50
msgid ""
"# Sprite lists\n"
"self.player_list = arcade.SpriteList()\n"
"self.wall_list = arcade.SpriteList()"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:57
msgid "Then reset the score and create the player:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:59
msgid ""
"# Reset the score\n"
"self.score = 0\n"
"\n"
"# Create the player\n"
"self.player_sprite = arcade.Sprite(\"images/character.png\", SPRITE_SCALING_PLAYER)\n"
"self.player_sprite.center_x = 50\n"
"self.player_sprite.center_y = 64\n"
"self.player_list.append(self.player_sprite)"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:70
msgid "Then go ahead and draw everything in our ``on_draw``:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:72
msgid ""
"def on_draw(self):\n"
"    arcade.start_render()\n"
"    self.wall_list.draw()\n"
"    self.player_list.draw()"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:79
msgid "Run the program and make sure it works."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:82
msgid ".. image:: chapters/22_sprites_and_walls/just_player.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:86
msgid "Individually Placing Walls"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:87
msgid ""
"In our ``setup`` method, we can position individual boxes to be used as "
"\"walls\":"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:89
msgid ""
"# Manually create and position a box at 300, 200\n"
"wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"wall.center_x = 300\n"
"wall.center_y = 200\n"
"self.wall_list.append(wall)\n"
"\n"
"# Manually create and position a box at 364, 200\n"
"wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"wall.center_x = 364\n"
"wall.center_y = 200\n"
"self.wall_list.append(wall)"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:103
msgid "Go ahead and try it out. It should look like:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:106
msgid ".. image:: chapters/22_sprites_and_walls/with_two_boxes.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:107
#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:160
msgid "Full listing below:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:109
msgid "sprite_move_walls.py Step 2"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:109
msgid ""
"\"\"\" Sprite Sample Program \"\"\"\n"
"\n"
"import arcade\n"
"\n"
"# --- Constants ---\n"
"SPRITE_SCALING_BOX = 0.5\n"
"SPRITE_SCALING_PLAYER = 0.5\n"
"\n"
"SCREEN_WIDTH = 800\n"
"SCREEN_HEIGHT = 600\n"
"\n"
"MOVEMENT_SPEED = 5\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"    \"\"\" This class represents the main window of the game. \"\"\"\n"
"\n"
"    def __init__(self):\n"
"        \"\"\" Initializer \"\"\"\n"
"        # Call the parent class initializer\n"
"        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, \"Sprite Example\")\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = None\n"
"        self.wall_list = None\n"
"\n"
"        # Set up the player\n"
"        self.player_sprite = None\n"
"\n"
"    def setup(self):\n"
"\n"
"        # Set the background color\n"
"        arcade.set_background_color(arcade.color.AMAZON)\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = arcade.SpriteList()\n"
"        self.wall_list = arcade.SpriteList()\n"
"\n"
"        # Reset the score\n"
"        self.score = 0\n"
"\n"
"        # Create the player\n"
"        self.player_sprite = arcade.Sprite(\"images/character.png\", SPRITE_SCALING_PLAYER)\n"
"        self.player_sprite.center_x = 50\n"
"        self.player_sprite.center_y = 64\n"
"        self.player_list.append(self.player_sprite)\n"
"\n"
"        # Manually create and position a box at 300, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 300\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"        # Manually create and position a box at 364, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 364\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"    def on_draw(self):\n"
"        arcade.start_render()\n"
"        self.wall_list.draw()\n"
"        self.player_list.draw()\n"
"\n"
"\n"
"def main():\n"
"    \"\"\" Main method \"\"\"\n"
"    window = MyGame()\n"
"    window.setup()\n"
"    arcade.run()\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:117
msgid "Placing Walls With A Loop"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:119
msgid ""
"In our ``setup`` method, we can create a row of box sprites using a ``for`` "
"loop. In the code below, our y value is always 350, and we change the x "
"value from 173 to 650. We put a box every 64 pixels because each box happens"
" to be 64 pixels wide."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:124
msgid ""
"# Place boxes inside a loop\n"
"for x in range(173, 650, 64):\n"
"    wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"    wall.center_x = x\n"
"    wall.center_y = 350\n"
"    self.wall_list.append(wall)"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:135
msgid ".. image:: chapters/22_sprites_and_walls/boxes_loop.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:139
msgid "Placing Walls With A List"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:141
msgid ""
"You could even create a list of coordinates, and then just loop through that"
" list creating walls:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:143
msgid ""
"# --- Place walls with a list\n"
"coordinate_list = [[400, 500],\n"
"                   [470, 500],\n"
"                   [400, 570],\n"
"                   [470, 570]]\n"
"\n"
"# Loop through coordinates\n"
"for coordinate in coordinate_list:\n"
"    wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"    wall.center_x = coordinate[0]\n"
"    wall.center_y = coordinate[1]\n"
"    self.wall_list.append(wall)"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:159
msgid ".. image:: chapters/22_sprites_and_walls/list.png"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:162
msgid "sprite_move_walls.py Step 3"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:162
msgid ""
"\"\"\" Sprite Sample Program \"\"\"\n"
"\n"
"import arcade\n"
"\n"
"# --- Constants ---\n"
"SPRITE_SCALING_BOX = 0.5\n"
"SPRITE_SCALING_PLAYER = 0.5\n"
"\n"
"SCREEN_WIDTH = 800\n"
"SCREEN_HEIGHT = 600\n"
"\n"
"MOVEMENT_SPEED = 5\n"
"\n"
"class MyGame(arcade.Window):\n"
"    \"\"\" This class represents the main window of the game. \"\"\"\n"
"\n"
"    def __init__(self):\n"
"        \"\"\" Initializer \"\"\"\n"
"        # Call the parent class initializer\n"
"        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, \"Sprite Example\")\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = None\n"
"        self.wall_list = None\n"
"\n"
"        # Set up the player\n"
"        self.player_sprite = None\n"
"\n"
"    def setup(self):\n"
"\n"
"        # Set the background color\n"
"        arcade.set_background_color(arcade.color.AMAZON)\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = arcade.SpriteList()\n"
"        self.wall_list = arcade.SpriteList()\n"
"\n"
"        # Reset the score\n"
"        self.score = 0\n"
"\n"
"        # Create the player\n"
"        self.player_sprite = arcade.Sprite(\"images/character.png\", SPRITE_SCALING_PLAYER)\n"
"        self.player_sprite.center_x = 50\n"
"        self.player_sprite.center_y = 64\n"
"        self.player_list.append(self.player_sprite)\n"
"\n"
"        # --- Manually place walls\n"
"\n"
"        # Manually create and position a box at 300, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 300\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"        # Manually create and position a box at 364, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 364\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"        # --- Place boxes inside a loop\n"
"        for x in range(173, 650, 64):\n"
"            wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"            wall.center_x = x\n"
"            wall.center_y = 350\n"
"            self.wall_list.append(wall)\n"
"\n"
"        # --- Place walls with a list\n"
"        coordinate_list = [[400, 500],\n"
"                           [470, 500],\n"
"                           [400, 570],\n"
"                           [470, 570]]\n"
"\n"
"        # Loop through coordinates\n"
"        for coordinate in coordinate_list:\n"
"            wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"            wall.center_x = coordinate[0]\n"
"            wall.center_y = coordinate[1]\n"
"            self.wall_list.append(wall)\n"
"\n"
"\n"
"    def on_draw(self):\n"
"        arcade.start_render()\n"
"        self.player_list.draw()\n"
"        self.wall_list.draw()\n"
"\n"
"\n"
"def main():\n"
"    \"\"\" Main method \"\"\"\n"
"    window = MyGame()\n"
"    window.setup()\n"
"    arcade.run()\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:169
msgid "Physics Engine"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:171
msgid "First, we need to hook the keyboard up to the player:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:173
msgid ""
"def on_key_press(self, key, modifiers):\n"
"    \"\"\"Called whenever a key is pressed. \"\"\"\n"
"\n"
"    if key == arcade.key.UP:\n"
"        self.player_sprite.change_y = MOVEMENT_SPEED\n"
"    elif key == arcade.key.DOWN:\n"
"        self.player_sprite.change_y = -MOVEMENT_SPEED\n"
"    elif key == arcade.key.LEFT:\n"
"        self.player_sprite.change_x = -MOVEMENT_SPEED\n"
"    elif key == arcade.key.RIGHT:\n"
"        self.player_sprite.change_x = MOVEMENT_SPEED\n"
"\n"
"def on_key_release(self, key, modifiers):\n"
"    \"\"\"Called when the user releases a key. \"\"\"\n"
"\n"
"    if key == arcade.key.UP or key == arcade.key.DOWN:\n"
"        self.player_sprite.change_y = 0\n"
"    elif key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"        self.player_sprite.change_x = 0"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:196
msgid "Now, we need to add a way to stop the player from running into walls."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:198
msgid ""
"The Arcade Library has a built in \"physics engine.\" A physics engine "
"handles the interactions between the virtual physical objects in the game. "
"For example, a physics engine might be several balls running into each "
"other, a character sliding down a hill, or a car making a turn on the road."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:203
msgid ""
"Physics engines have made impressive gains on what they can simulate. For "
"our game, we'll just keep things simple and make sure our character can't "
"walk through walls."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:207
msgid "We'll create variable to hold our physics engine in the ``__init__``:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:209
msgid ""
"# This variable holds our simple \"physics engine\"\n"
"self.physics_engine = None"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:214
msgid ""
"We can create the actual physics engine in our ``setup`` method with the "
"following code:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:217
msgid ""
"self.physics_engine = arcade.PhysicsEngineSimple(self.player_sprite, "
"self.wall_list)"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:221
msgid ""
"This identifies the player character (``player_sprite``), and a list of "
"sprites (``wall_list``) that the player character isn't allowed to pass "
"through."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:224
msgid ""
"Before, we updated all the sprites with a ``self.all_sprites_list.update()``"
" command. With the physics engine, we will instead update the sprites by "
"using the physics engine's update:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:228
msgid ""
"def update(self, delta_time):\n"
"    self.physics_engine.update()"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:233
msgid "The simple physics engine follows the following algorithm:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:235
msgid ""
"Move the player in the x direction according to the player's ``change_x`` "
"value."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:237
msgid ""
"Check the player against the wall list and see if there are any collisions."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:238
msgid "If the player is colliding:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:240
msgid ""
"If the player is moving right, set the player's right edge to the wall's "
"left edge."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:242
msgid ""
"If the player is moving left, set the player's left edge to the wall's right"
" edge."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:244
msgid ""
"If the player isn't moving left or right, print out a message that we are "
"confused how we hit something when we aren't moving."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:247
msgid "Then we just do the same thing, except with the y coordinates."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:249
msgid "You can see the `physics engine source code`_ on GitHub."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:254
msgid "Here's the full example:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:256
msgid "sprite_move_walls.py"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:256
msgid ""
"\"\"\" Sprite Sample Program \"\"\"\n"
"\n"
"import arcade\n"
"\n"
"# --- Constants ---\n"
"SPRITE_SCALING_BOX = 0.5\n"
"SPRITE_SCALING_PLAYER = 0.5\n"
"\n"
"SCREEN_WIDTH = 800\n"
"SCREEN_HEIGHT = 600\n"
"\n"
"MOVEMENT_SPEED = 5\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"    \"\"\" This class represents the main window of the game. \"\"\"\n"
"\n"
"    def __init__(self):\n"
"        \"\"\" Initializer \"\"\"\n"
"        # Call the parent class initializer\n"
"        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, \"Sprite Example\")\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = None\n"
"        self.wall_list = None\n"
"\n"
"        # Set up the player\n"
"        self.player_sprite = None\n"
"\n"
"        # This variable holds our simple \"physics engine\"\n"
"        self.physics_engine = None\n"
"\n"
"    def setup(self):\n"
"\n"
"        # Set the background color\n"
"        arcade.set_background_color(arcade.color.AMAZON)\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = arcade.SpriteList()\n"
"        self.wall_list = arcade.SpriteList()\n"
"\n"
"        # Reset the score\n"
"        self.score = 0\n"
"\n"
"        # Create the player\n"
"        self.player_sprite = arcade.Sprite(\"images/character.png\", SPRITE_SCALING_PLAYER)\n"
"        self.player_sprite.center_x = 50\n"
"        self.player_sprite.center_y = 64\n"
"        self.player_list.append(self.player_sprite)\n"
"\n"
"        # --- Manually place walls\n"
"\n"
"        # Manually create and position a box at 300, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 300\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"        # Manually create and position a box at 364, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 364\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"        # --- Place boxes inside a loop\n"
"        for x in range(173, 650, 64):\n"
"            wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"            wall.center_x = x\n"
"            wall.center_y = 350\n"
"            self.wall_list.append(wall)\n"
"\n"
"        # --- Place walls with a list\n"
"        coordinate_list = [[400, 500],\n"
"                           [470, 500],\n"
"                           [400, 570],\n"
"                           [470, 570]]\n"
"\n"
"        # Loop through coordinates\n"
"        for coordinate in coordinate_list:\n"
"            wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"            wall.center_x = coordinate[0]\n"
"            wall.center_y = coordinate[1]\n"
"            self.wall_list.append(wall)\n"
"\n"
"        # Create the physics engine. Give it a reference to the player, and\n"
"        # the walls we can't run into.\n"
"        self.physics_engine = arcade.PhysicsEngineSimple(self.player_sprite, self.wall_list)\n"
"\n"
"    def on_draw(self):\n"
"        arcade.start_render()\n"
"        self.wall_list.draw()\n"
"        self.player_list.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.physics_engine.update()\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\"Called whenever a key is pressed. \"\"\"\n"
"\n"
"        if key == arcade.key.UP:\n"
"            self.player_sprite.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.player_sprite.change_y = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.LEFT:\n"
"            self.player_sprite.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.player_sprite.change_x = MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\"Called when the user releases a key. \"\"\"\n"
"\n"
"        if key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.player_sprite.change_y = 0\n"
"        elif key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.player_sprite.change_x = 0\n"
"\n"
"\n"
"def main():\n"
"    \"\"\" Main method \"\"\"\n"
"    window = MyGame()\n"
"    window.setup()\n"
"    arcade.run()\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:262
msgid "Using a View Port for Scrolling"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:264
msgid ""
"What if one screen isn't enough to hold your maze of walls? We can have a "
"world that is larger than just our window. We do this by adjusting the *view"
" port*. Normally coordinate (0, 0) is the lower left corner of our screen. "
"We can change that! We could have an entire world stretch from (0, 0) to "
"(3000, 3000), and have a smaller view port that was 800x640 that scrolled "
"around that."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:271
msgid ""
"The command for using the view port is ``set_viewport``. This command takes "
"four arguments. The first two are the left and bottom boundaries of the "
"window. By default these are zero. That is why (0, 0) is in the lower left "
"of the screen. The next two commands are the top and right coordinates of "
"the screen. By default these are the screen width and height, minus one. So "
"an 800 pixel-wide window would have x-coordinates from 0 - 799."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:278
msgid ""
"A command like this would shift the whole \"view\" of the window 200 pixels "
"to the right:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:281
msgid ""
"# Specify viewport size by (left, right, bottom, top)\n"
"arcade.set_viewport(200, 200 + SCREEN_WIDTH - 1, 0, SCREEN_HEIGHT - 1)"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:286
msgid ""
"So with a 800 wide pixel window, we would show x-coordinates 200 - 999 "
"instead of 0 - 799."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:289
msgid ""
"Instead of hard-coding the shift at 200 pixels, we need to use a variable "
"and have rules around when to shift the view. In our next example, we will "
"create two new instance variables in our application class that hold the "
"left and bottom coordinates for our view port. We'll default to zero."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:294
msgid ""
"self.view_left = 0\n"
"self.view_bottom = 0"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:300
msgid ""
"We are also going to create two new constants. We don't want the player to "
"reach the edge of the screen before we start scrolling. Because then the "
"player would have no idea where she is going. In our example we will set a "
"\"margin\" of 150 pixels. When the player is 150 pixels from the edge of the"
" screen, we'll move the view port so she can see at least 150 pixels around "
"her."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:306
msgid "VIEWPORT_MARGIN = 150"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:310
msgid ""
"Next, in our update method, we need to see if the user has moved too close "
"to the edge of the screen and we need to update the boundaries."
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:313
msgid ""
"# Keep track of if we changed the boundary. We don't want to call the\n"
"# set_viewport command if we didn't change the view port.\n"
"changed = False\n"
"\n"
"# Scroll left\n"
"left_boundary = self.view_left + VIEWPORT_MARGIN\n"
"if self.player_sprite.left < left_boundary:\n"
"    self.view_left -= left_boundary - self.player_sprite.left\n"
"    changed = True\n"
"\n"
"# Scroll right\n"
"right_boundary = self.view_left + SCREEN_WIDTH - VIEWPORT_MARGIN\n"
"if self.player_sprite.right > right_boundary:\n"
"    self.view_left += self.player_sprite.right - right_boundary\n"
"    changed = True\n"
"\n"
"# Scroll up\n"
"top_boundary = self.view_bottom + SCREEN_HEIGHT - VIEWPORT_MARGIN\n"
"if self.player_sprite.top > top_boundary:\n"
"    self.view_bottom += self.player_sprite.top - top_boundary\n"
"    changed = True\n"
"\n"
"# Scroll down\n"
"bottom_boundary = self.view_bottom + VIEWPORT_MARGIN\n"
"if self.player_sprite.bottom < bottom_boundary:\n"
"    self.view_bottom -= bottom_boundary - self.player_sprite.bottom\n"
"    changed = True\n"
"\n"
"# Make sure our boundaries are integer values. While the view port does\n"
"# support floating point numbers, for this application we want every pixel\n"
"# in the view port to map directly onto a pixel on the screen. We don't want\n"
"# any rounding errors.\n"
"self.view_left = int(self.view_left)\n"
"self.view_bottom = int(self.view_bottom)\n"
"\n"
"# If we changed the boundary values, update the view port to match\n"
"if changed:\n"
"    arcade.set_viewport(self.view_left,\n"
"                        SCREEN_WIDTH + self.view_left - 1,\n"
"                        self.view_bottom,\n"
"                        SCREEN_HEIGHT + self.view_bottom - 1)"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:357
msgid "The full example is below:"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:359
msgid "sprite_move_scrolling.py"
msgstr ""

#: ../../source/chapters/22_sprites_and_walls/sprites_and_walls.rst:359
msgid ""
"\"\"\" Sprite Sample Program \"\"\"\n"
"\n"
"import arcade\n"
"\n"
"# --- Constants ---\n"
"SPRITE_SCALING_BOX = 0.5\n"
"SPRITE_SCALING_PLAYER = 0.5\n"
"\n"
"SCREEN_WIDTH = 800\n"
"SCREEN_HEIGHT = 600\n"
"\n"
"MOVEMENT_SPEED = 5\n"
"\n"
"VIEWPORT_MARGIN = 150\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"    \"\"\" This class represents the main window of the game. \"\"\"\n"
"\n"
"    def __init__(self):\n"
"        \"\"\" Initializer \"\"\"\n"
"        # Call the parent class initializer\n"
"        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, \"Sprite Example\")\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = None\n"
"        self.wall_list = None\n"
"\n"
"        # Set up the player\n"
"        self.player_sprite = None\n"
"\n"
"        # This variable holds our simple \"physics engine\"\n"
"        self.physics_engine = None\n"
"\n"
"        # Manage the view port\n"
"        self.view_left = 0\n"
"        self.view_bottom = 0\n"
"\n"
"    def setup(self):\n"
"\n"
"        # Set the background color\n"
"        arcade.set_background_color(arcade.color.AMAZON)\n"
"\n"
"        # Reset the view port\n"
"        self.view_left = 0\n"
"        self.view_bottom = 0\n"
"\n"
"        # Sprite lists\n"
"        self.player_list = arcade.SpriteList()\n"
"        self.wall_list = arcade.SpriteList()\n"
"\n"
"        # Reset the score\n"
"        self.score = 0\n"
"\n"
"        # Create the player\n"
"        self.player_sprite = arcade.Sprite(\"images/character.png\", SPRITE_SCALING_PLAYER)\n"
"        self.player_sprite.center_x = 50\n"
"        self.player_sprite.center_y = 64\n"
"        self.player_list.append(self.player_sprite)\n"
"\n"
"        # --- Manually place walls\n"
"\n"
"        # Manually create and position a box at 300, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 300\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"        # Manually create and position a box at 364, 200\n"
"        wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"        wall.center_x = 364\n"
"        wall.center_y = 200\n"
"        self.wall_list.append(wall)\n"
"\n"
"        # --- Place boxes inside a loop\n"
"        for x in range(173, 650, 64):\n"
"            wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"            wall.center_x = x\n"
"            wall.center_y = 350\n"
"            self.wall_list.append(wall)\n"
"\n"
"        # --- Place walls with a list\n"
"        coordinate_list = [[400, 500],\n"
"                           [470, 500],\n"
"                           [400, 570],\n"
"                           [470, 570]]\n"
"\n"
"        # Loop through coordinates\n"
"        for coordinate in coordinate_list:\n"
"            wall = arcade.Sprite(\"images/boxCrate_double.png\", SPRITE_SCALING_BOX)\n"
"            wall.center_x = coordinate[0]\n"
"            wall.center_y = coordinate[1]\n"
"            self.wall_list.append(wall)\n"
"\n"
"        # Create the physics engine. Give it a reference to the player, and\n"
"        # the walls we can't run into.\n"
"        self.physics_engine = arcade.PhysicsEngineSimple(self.player_sprite, self.wall_list)\n"
"\n"
"    def on_draw(self):\n"
"        arcade.start_render()\n"
"        self.wall_list.draw()\n"
"        self.player_list.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.physics_engine.update()\n"
"\n"
"        # --- Manage Scrolling ---\n"
"\n"
"        # Keep track of if we changed the boundary. We don't want to call the\n"
"        # set_viewport command if we didn't change the view port.\n"
"        changed = False\n"
"\n"
"        # Scroll left\n"
"        left_boundary = self.view_left + VIEWPORT_MARGIN\n"
"        if self.player_sprite.left < left_boundary:\n"
"            self.view_left -= left_boundary - self.player_sprite.left\n"
"            changed = True\n"
"\n"
"        # Scroll right\n"
"        right_boundary = self.view_left + SCREEN_WIDTH - VIEWPORT_MARGIN\n"
"        if self.player_sprite.right > right_boundary:\n"
"            self.view_left += self.player_sprite.right - right_boundary\n"
"            changed = True\n"
"\n"
"        # Scroll up\n"
"        top_boundary = self.view_bottom + SCREEN_HEIGHT - VIEWPORT_MARGIN\n"
"        if self.player_sprite.top > top_boundary:\n"
"            self.view_bottom += self.player_sprite.top - top_boundary\n"
"            changed = True\n"
"\n"
"        # Scroll down\n"
"        bottom_boundary = self.view_bottom + VIEWPORT_MARGIN\n"
"        if self.player_sprite.bottom < bottom_boundary:\n"
"            self.view_bottom -= bottom_boundary - self.player_sprite.bottom\n"
"            changed = True\n"
"\n"
"        # Make sure our boundaries are integer values. While the view port does\n"
"        # support floating point numbers, for this application we want every pixel\n"
"        # in the view port to map directly onto a pixel on the screen. We don't want\n"
"        # any rounding errors.\n"
"        self.view_left = int(self.view_left)\n"
"        self.view_bottom = int(self.view_bottom)\n"
"\n"
"        # If we changed the boundary values, update the view port to match\n"
"        if changed:\n"
"            arcade.set_viewport(self.view_left,\n"
"                                SCREEN_WIDTH + self.view_left - 1,\n"
"                                self.view_bottom,\n"
"                                SCREEN_HEIGHT + self.view_bottom - 1)\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\" Called whenever a key is pressed. \"\"\"\n"
"\n"
"        if key == arcade.key.UP:\n"
"            self.player_sprite.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.player_sprite.change_y = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.LEFT:\n"
"            self.player_sprite.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.player_sprite.change_x = MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\"Called when the user releases a key. \"\"\"\n"
"\n"
"        if key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.player_sprite.change_y = 0\n"
"        elif key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.player_sprite.change_x = 0\n"
"\n"
"\n"
"def main():\n"
"    \"\"\" Main method \"\"\"\n"
"    window = MyGame()\n"
"    window.setup()\n"
"    arcade.run()\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
msgstr ""
