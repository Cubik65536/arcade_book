# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Paul Vincent Craven
# This file is distributed under the same license as the Arcade package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Arcade 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-13 15:19-0500\n"
"PO-Revision-Date: 2020-04-03 18:43+0000\n"
"Language-Team: Swedish (https://www.transifex.com/arcade-academy/teams/108729/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../source/chapters/16_user_control/user_control.rst:4
msgid "User Control"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:6
msgid ""
"How do we interact with the user? Get the user to move an object on the "
"screen?"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:8
msgid ""
"We can do this with the mouse, with the keyboard, or with the game "
"controller."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:11
msgid "Move with the Mouse"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:13
msgid ""
"The key to managing mouse motion to override the ``on_mouse_motion`` in the "
"``arcade.Window`` class. That method is called every time the mouse moves. "
"The method definition looks like this:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:17
msgid "def on_mouse_motion(self, x, y, dx, dy):"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:21
msgid ""
"The ``x`` and ``y`` are the coordinates of the mouse. the ``dx`` and ``dy`` "
"represent the change in x and y since the last time the method was called."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:24
msgid ""
"Often when controlling a graphical item on the screen with the mouse, we do "
"not want to see the mouse pointer. If you don't want to see the mouse "
"pointer, in the ``__init__`` method, call the following method in the parent"
" class:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:28
msgid "self.set_mouse_visible(False)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:32
msgid ""
"The example below takes our ``Ball`` class, and moves it around the screen "
"with the mouse."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:35
msgid "move_with_mouse.py"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:35
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, self.radius, self.color)\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def on_mouse_motion(self, x, y, dx, dy):\n"
"        \"\"\" Called to update our objects. Happens approximately 60 times per second.\"\"\"\n"
"        self.ball.position_x = x\n"
"        self.ball.position_y = y\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:44
msgid "Mouse Clicks"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:46
msgid ""
"You can also process mouse clicks by defining an ``on_mouse_press`` method:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:48
msgid ""
"def on_mouse_press(self, x, y, button, modifiers):\n"
"    \"\"\" Called when the user presses a mouse button. \"\"\"\n"
"\n"
"    if button == arcade.MOUSE_BUTTON_LEFT:\n"
"        print(\"Left mouse button pressed at\", x, y)\n"
"    elif button == arcade.MOUSE_BUTTON_RIGHT:\n"
"        print(\"Right mouse button pressed at\", x, y)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:59
msgid "Move with the Keyboard"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:61
msgid ""
"Moving with the game controller is similar to our bouncing ball example. "
"There are just two differences:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:64
msgid "We control the ``change_x`` and ``change_y`` with the keyboard"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:65
msgid "When we hit the edge of the screen we stop, rather than bounce."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:67
msgid ""
"To detect when a key is hit, we override the ``on_key_press`` method. We "
"might think of hitting a key as one event. But it is actually two. When the "
"key is pressed, we start moving. When the key is released we stop moving. "
"That makes for two events. Releasing a key is controlled by "
"``on_key_release``."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:72
msgid ""
"These methods have a  ``key`` variable as a parameter that can be compared "
"with an ``if`` statement to the values in the `arcade.key library "
"<http://arcade.academy/arcade.key.html>`_."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:76
msgid ""
"def on_key_press(self, key, modifiers):\n"
"    if key == arcade.key.LEFT:\n"
"        print(\"Left key hit\")\n"
"    elif key == arcade.key.A:\n"
"        print(\"The 'a' key was hit\")"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:84
msgid ""
"We can use this in a program to move a ball around the screen. See the "
"highlighted lines in the program below:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:87
msgid "move_with_keyboard_simple.py"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:87
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 3\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.ball.update()\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\" Called whenever the user presses a key. \"\"\"\n"
"        if key == arcade.key.LEFT:\n"
"            self.ball.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.ball.change_x = MOVEMENT_SPEED\n"
"        elif key == arcade.key.UP:\n"
"            self.ball.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.ball.change_y = -MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\" Called whenever a user releases a key. \"\"\"\n"
"        if key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.ball.change_x = 0\n"
"        elif key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.ball.change_y = 0\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:94
msgid "Keep From Moving Off Screen"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:96
msgid ""
"Unfortunately in the prior program, there is nothing that keeps the player "
"from moving off-screen. If we want to stop the player from moving off-screen"
" we need some additional code."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:100
msgid ""
"We detect the edge by comparing ``position_x`` with the left and right side "
"of the screen For example:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:103
msgid "if self.position_x < 0:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:107
msgid ""
"But this isn't perfect. Because the position specifies the *center* of the "
"ball, by the time the x coordinate is 0 we are already have off the screen. "
"It is better to compare it to the ball's radius:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:111
msgid "if self.position_x < self.radius:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:115
msgid ""
"What do we do once it hits the edge? Just set the value back to the edge:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:117
msgid ""
"# See if the ball hit the edge of the screen. If so, change direction\n"
"if self.position_x < self.radius:\n"
"    self.position_x = self.radius"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:123
msgid "Here's a full example:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:125
msgid "move_with_keyboard_edge_detect.py"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:125
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 3\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.ball.update()\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\" Called whenever the user presses a key. \"\"\"\n"
"        if key == arcade.key.LEFT:\n"
"            self.ball.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.ball.change_x = MOVEMENT_SPEED\n"
"        elif key == arcade.key.UP:\n"
"            self.ball.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.ball.change_y = -MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\" Called whenever a user releases a key. \"\"\"\n"
"        if key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.ball.change_x = 0\n"
"        elif key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.ball.change_y = 0\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:132
msgid "Moving with the Game Controller"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:134
msgid ""
"Working with game controllers is a bit more complex. A computer might not "
"have any game controllers, or it might have five controllers plugged in."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:137
msgid ""
"We can get a list of all game pads that are plugged in with the "
"``get_joysticks`` function. This will either return a list, or it will "
"return nothing at all if there are no game pads."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:141
msgid ""
"Below is a block of code that can be put in an ``__init__`` method for your "
"application that will create an instance variable to represent a game pad if"
" one exists."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:145
msgid ""
"joysticks = arcade.get_joysticks()\n"
"if joysticks:\n"
"    self.joystick = joysticks[0]\n"
"    self.joystick.open()\n"
"else:\n"
"    print(\"There are no joysticks.\")\n"
"    self.joystick = None"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:157
msgid "Joystick Values"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:159
msgid ""
"After this, you can get the position of the game controller joystick by "
"calling ``self.joystick.x`` and ``self.joystick.y``."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:162
msgid "Try this, combined with the initialization code from above:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:164
msgid "move_with_game_controller_print.py"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:164
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 5\n"
"DEAD_ZONE = 0.02\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"        # Get a list of all the game controllers that are plugged in\n"
"        joysticks = arcade.get_joysticks()\n"
"\n"
"        # If we have a game controller plugged in, grab it and\n"
"        # make an instance variable out of it.\n"
"        if joysticks:\n"
"            self.joystick = joysticks[0]\n"
"            self.joystick.open()\n"
"        else:\n"
"            print(\"There are no joysticks.\")\n"
"            self.joystick = None\n"
"\n"
"    def on_draw(self):\n"
"\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"\n"
"        # Update the position according to the game controller\n"
"        if self.joystick:\n"
"            print(self.joystick.x, self.joystick.y)\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:170
msgid ""
"Run the program and see the values it prints out for your game controller as"
" you move the joystick on it around."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:173
msgid ""
"The values will be between -1 and +1, with 0 being a centered joystick."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:174
msgid ""
"The x-axis numbers will be negative if the stick goes left, positive for "
"right."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:175
msgid ""
"The y-axis numbers will be opposite of what you might expect. Negative for "
"up, positive for down."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:179
msgid ".. image:: chapters/16_user_control/c.jpg"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:179
msgid "Centered (0, 0)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:183
msgid ".. image:: chapters/16_user_control/d.jpg"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:183
msgid "Down (0, 1)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:187
msgid ".. image:: chapters/16_user_control/dl.jpg"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:187
msgid "Down/Left (-1, 1)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:191
msgid ".. image:: chapters/16_user_control/dr.jpg"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:191
msgid "Down/Right (1, 1)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:195
msgid ".. image:: chapters/16_user_control/u.jpg"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:195
msgid "Up (0, -1)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:199
msgid ".. image:: chapters/16_user_control/ul.jpg"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:199
msgid "Up/Left (-1, -1)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:203
msgid ".. image:: chapters/16_user_control/ur.jpg"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:203
msgid "Up/Right (1, -1)"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:205
msgid "We can move the ball by adding the following code to the ``update``:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:207
msgid ""
"def update(self, delta_time):\n"
"\n"
"    # Update the position according to the game controller\n"
"    if self.joystick:\n"
"        print(self.joystick.x, self.joystick.y)\n"
"\n"
"        self.ball.change_x = self.joystick.x\n"
"        self.ball.change_y = -self.joystick.y"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:219
msgid ""
"Notice the ``-`` we put in front of setting the y vector. If we don't do "
"this, the ball will move opposite of what we expect when going up/down. This"
" is because the joystick has y values mapped opposite of how we'd normally "
"expect. There's a long story to that, which I will not bore you with now."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:224
msgid ""
"But with this code our ball moves *so slow*. How do we speed it up? We can "
"make it run five times faster by multiplying by five if we want."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:227
msgid ""
"def update(self, delta_time):\n"
"\n"
"    # Update the position according to the game controller\n"
"    if self.joystick:\n"
"        print(self.joystick.x, self.joystick.y)\n"
"\n"
"        self.ball.change_x = self.joystick.x * 5\n"
"        self.ball.change_y = -self.joystick.y * 5"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:239
msgid ""
"Or better yet, define a constant variable at the top of your program and use"
" that. In our final example below, we'll do just that."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:244
msgid "Deadzone"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:246
msgid "What if your ball 'drifts' when you have the joystick centered?"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:248
msgid ""
"Joysticks are mechanical. A centered joystick might have a value not at 0, "
"but at 0.0001 or some small number. This will make for a small \"drift\" on "
"a person's character. We often counteract this by having a \"dead zone\" "
"where if the number is below a certain value, we just assume it is zero to "
"eliminate the drift."
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:254
msgid "See the highlighted lines for how we take care of the dead zone:"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:256
msgid "move_with_game_controller.py"
msgstr ""

#: ../../source/chapters/16_user_control/user_control.rst:256
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 5\n"
"DEAD_ZONE = 0.02\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"        # Get a list of all the game controllers that are plugged in\n"
"        joysticks = arcade.get_joysticks()\n"
"\n"
"        # If we have a game controller plugged in, grab it and\n"
"        # make an instance variable out of it.\n"
"        if joysticks:\n"
"            self.joystick = joysticks[0]\n"
"            self.joystick.open()\n"
"        else:\n"
"            print(\"There are no joysticks.\")\n"
"            self.joystick = None\n"
"\n"
"    def on_draw(self):\n"
"\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"\n"
"        # Update the position according to the game controller\n"
"        if self.joystick:\n"
"\n"
"            # Set a \"dead zone\" to prevent drive from a centered joystick\n"
"            if abs(self.joystick.x) < DEAD_ZONE:\n"
"                self.ball.change_x = 0\n"
"            else:\n"
"                self.ball.change_x = self.joystick.x * MOVEMENT_SPEED\n"
"\n"
"            # Set a \"dead zone\" to prevent drive from a centered joystick\n"
"            if abs(self.joystick.y) < DEAD_ZONE:\n"
"                self.ball.change_y = 0\n"
"            else:\n"
"                self.ball.change_y = -self.joystick.y * MOVEMENT_SPEED\n"
"\n"
"        self.ball.update()\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""
