# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Paul Vincent Craven
# This file is distributed under the same license as the Arcade package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Arcade 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-13 15:19-0500\n"
"PO-Revision-Date: 2020-04-03 18:44+0000\n"
"Language-Team: Swedish (https://www.transifex.com/arcade-academy/teams/108729/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../source/chapters/24_searching/searching.rst:2
msgid "Searching"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:4
msgid ""
"Searching is an important and very common operation that computers do all "
"the time. Searches are used every time someone does a ctrl-f for \"find\", "
"when a user uses \"type-to\" to quickly select an item, or when a web server"
" pulls information about a customer to present a customized web page with "
"the customer's order."
msgstr ""

#: ../../source/chapters/24_searching/searching.rstNone
msgid ".. image:: chapters/24_searching/search.png"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:13
msgid ""
"There are a lot of ways to search for data. Google has based an entire "
"multi-billion dollar company on this fact. This chapter introduces the two "
"simplest methods for searching, the linear search and the binary search."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:20
msgid "Reading From a File"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:26
msgid ""
"Before discussing how to search we need to learn how to read data from a "
"file. Reading in a data set from a file is way more fun than typing it in by"
" hand each time."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:30
msgid ""
"Let's say we need to create a program that will allow us to quickly find the"
" name of a super-villain. To start with, our program needs a database of "
"super-villains. To download this data set, download and save this file:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:34
msgid "`super_villains.txt`_"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:38
msgid ""
"These are random names generated by the `nine.frenchboys.net`_ website, "
"although last I checked they no longer have a super-villain generator. They "
"have other cool random name generators though."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:44
msgid "Save this file and remember which directory you saved it to."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:46
msgid ""
"In the same directory as ``super_villains.txt``, create, save, and run the "
"following Python program:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:49
#: ../../source/chapters/24_searching/searching.rst:101
msgid "Read in a file"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:49
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        print(line)\n"
"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:68
msgid ""
"There is only one new command in this code: ``open``. Because it is a built-"
"in function like ``print``, there is no need for an ``import``. Full details"
" on this function can be found in the `Python documentation`_ but at this "
"point the documentation for that command is so technical it might not even "
"be worth looking at."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:76
msgid ""
"The above program has two problems with it, but it provides a simple example"
" of reading in a file. Line 6 opens a file and gets it ready to be read. The"
" name of the file is in between the quotes. The new variable ``my_file`` is "
"an object that represents the file being read. Line 9 shows how a normal "
"``for`` loop may be used to read through a file line by line. Think of the "
"file as a list of lines, and the new variable line will be set to each of "
"those lines as the program runs through the loop."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:84
msgid ""
"Try running the program. One of the problems with the it is that the text is"
" printed double-spaced. The reason for this is that each line pulled out of "
"the file and stored in the variable line includes the carriage return as "
"part of the string. Remember the carriage return and line feed introduced "
"back in Chapter 1? The ``print`` statement adds yet another carriage return "
"and the result is double-spaced output."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:91
msgid ""
"The second problem is that the file is opened, but not closed. This problem "
"isn't as obvious as the double-spacing issue, but it is important. The "
"Windows operating system can only open so many files at once. A file can "
"normally only be opened by one program at a time. Leaving a file open will "
"limit what other programs can do with the file and take up system resources."
" It is necessary to close the file to let Windows know the program is no "
"longer working with that file. In this case it is not too important because "
"once any program is done running, the Windows will automatically close any "
"files left open. But since it is a bad habit to program like that, let's "
"update the code:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:101
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the line\n"
"        line = line.strip()\n"
"        print(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:124
msgid ""
"The listing above works better. It has two new additions. On line 11 is a "
"call to the ``strip`` method built into every ``String`` class. This "
"function returns a new string without the trailing spaces and carriage "
"returns of the original string. The method does not alter the original "
"string but instead creates a new one. This line of code would not work:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:130
msgid "line.strip()"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:134
msgid ""
"If the programmer wants the original variable to reference the new string, "
"she must assign it to the new returned string as shown on line 11."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:137
msgid ""
"The second addition is on line 14. This closes the file so that the "
"operating system doesn't have to go around later and clean up open files "
"after the program ends."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:144
msgid "Reading Into an Array"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:146
msgid ""
"It is useful to read in the contents of a file to an array so that the "
"program can do processing on it later. This can easily be done in python "
"with the following code:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:151
msgid "Read in a file from disk and put it in an array"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:151
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    print( \"There were\", len(name_list), \"names in the file.\")\n"
"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:181
msgid ""
"This combines the new pattern of how to read a file, along with the "
"previously learned pattern of how to create an empty array and append to it "
"as new data comes in, which was shown back in :ref:`append_to_list`. To "
"verify the file was read into the array correctly a programmer could print "
"the length of the array:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:186
msgid "print( \"There were\",len(name_list),\"names in the file.\")"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:190
msgid "Or the programmer could print the entire contents of the array:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:192
msgid ""
"for name in name_list:\n"
"    print(name)"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:197
msgid ""
"Go ahead and make sure you can read in the file before continuing on to the "
"different searches."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:201
msgid "Linear Search"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:203
msgid ""
"If a program has a set of data in an array, how can it go about finding "
"where a specific element is? This can be done one of two ways. The first "
"method is to use a *linear search*. This starts at the first element, and "
"keeps comparing elements until it finds the desired element (or runs out of "
"elements.)"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:211
msgid "Linear Search Algorithm"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:217
#: ../../source/chapters/24_searching/searching.rst:264
#: ../../source/chapters/24_searching/searching.rst:273
msgid "Linear search"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:217
msgid ""
"# --- Linear search\n"
"key = \"Morgiana the Shrew\"\n"
"\n"
"# Start at the beginning of the list\n"
"current_list_position = 0\n"
"\n"
"# Loop until you reach the end of the list, or the value at the\n"
"# current position is equal to the key\n"
"while current_list_position < len(name_list) and name_list[current_list_position] != key:\n"
"\n"
"    # Advance to the next item in the list\n"
"    current_list_position += 1\n"
"\n"
"if current_list_position < len(name_list):\n"
"    print(\"The name is at position\", current_list_position)\n"
"else:\n"
"    print(\"The name was not in the list.\")"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:239
msgid ""
"The linear search is rather simple. Line 5 sets up an increment variable "
"that will keep track of exactly where in the list the program needs to check"
" next. The first element that needs to be checked is zero, so "
"``current_list_position`` is set to zero."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:243
msgid ""
"The next line is a bit more complex. The computer needs to keep looping "
"until one of two things happens. It finds the element, or it runs out of "
"elements. The first comparison sees if the current element we are checking "
"is less than the length of the list. If so, we can keep looping. The second "
"comparison sees if the current element in the name list is equal to the name"
" we are searching for."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:250
msgid ""
"This check to see if the program has run out of elements *must occur first*."
" Otherwise the program will check against a non-existent element which will "
"cause an error."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:254
msgid ""
"Line 12 simply moves to the next element if the conditions to keep searching"
" are met in line 9."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:257
msgid ""
"At the end of the loop, the program checks to see if the end of the list was"
" reached on line 14. Remember, a list of n elements is numbered 0 to n-1. "
"Therefore if i is equal to the length of the list, the end has been reached."
" If it is less, we found the element."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:262
msgid ""
"The full example with both the reading in the file and the search is below:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:264
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    print(\"There were\", len(name_list), \"names in the file.\")\n"
"\n"
"    # --- Linear search\n"
"    key = \"Morgiana the Shrew\"\n"
"\n"
"    # Start at the beginning of the list\n"
"    current_list_position = 0\n"
"\n"
"    # Loop until you reach the end of the list, or the value at the\n"
"    # current position is equal to the key\n"
"    while current_list_position < len(name_list) and name_list[current_list_position] != key:\n"
"        # Advance to the next item in the list\n"
"        current_list_position += 1\n"
"\n"
"    if current_list_position < len(name_list):\n"
"        print(\"The name is at position\", current_list_position)\n"
"    else:\n"
"        print(\"The name was not in the list.\")\n"
"\n"
"\n"
"main()\n"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:270
msgid ""
"We can improve on this example by moving both the reading of the file and "
"the search into their own functions:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:273
msgid ""
"def read_in_file(file_name):\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(file_name)\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    return name_list\n"
"\n"
"\n"
"def linear_search(key, name_list):\n"
"    \"\"\" Linear search \"\"\"\n"
"\n"
"    # Start at the beginning of the list\n"
"    current_list_position = 0\n"
"\n"
"    # Loop until you reach the end of the list, or the value at the\n"
"    # current position is equal to the key\n"
"    while current_list_position < len(name_list) and name_list[current_list_position] != key:\n"
"\n"
"        # Advance to the next item in the list\n"
"        current_list_position += 1\n"
"\n"
"    return current_list_position\n"
"\n"
"\n"
"def main():\n"
"\n"
"    key = \"Morgiana the Shrew\"\n"
"    name_list = read_in_file(\"super_villains.txt\")\n"
"    list_position = linear_search(key, name_list)\n"
"\n"
"    if list_position < len(name_list):\n"
"        print(\"The name\", key, \"is at position\", list_position)\n"
"    else:\n"
"        print(\"The name\", key, \"was not in the list.\")\n"
"\n"
"\n"
"main()\n"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:279
msgid "Variations On The Linear Search"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:281
msgid ""
"Variations on the linear search can be used to create several common "
"algorithms. Specifically, you can use it to see if *any* items in a list "
"match a property, or if *all* items match a property. You can also use it to"
" pull all matching items out of a list."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:287
#: ../../source/chapters/24_searching/searching.rst:417
msgid "Does At Least One Item Have a Property?"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:289
msgid ""
"For example, here is a function that uses the linear search to see if there "
"is an item in ``my_list`` that matches the value in ``key``."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:292
msgid "check_if_one_item_has_property_v1"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:292
msgid ""
"def check_if_one_item_has_property_v1(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    list_position = 0\n"
"    while list_position < len(my_list) and my_list[list_position] != key:\n"
"        list_position += 1\n"
"\n"
"    if list_position < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:313
msgid ""
"Using the ``break`` statement, which exits a loop early, we can simplify the"
" code:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:316
msgid "check_if_one_item_has_property_v2"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:316
msgid ""
"def check_if_one_item_has_property_v2(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            # Found an item that matched. Return True\n"
"            return True\n"
"\n"
"    # Went through the whole list. Return False.\n"
"    return False"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:334
#: ../../source/chapters/24_searching/searching.rst:463
msgid "Do All Items Have a Property?"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:336
msgid ""
"How would you test to see if *all* items in a list match a property? We just"
" need to reverse a few things in the algorithm above."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:339
msgid "check_if_all_items_have_property"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:339
msgid ""
"def check_if_all_items_have_property(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item != key:\n"
"            # Found an item that didn't match. Return False.\n"
"            return False\n"
"\n"
"    # Got through the entire list. There were no mis-matches.\n"
"    return True"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:358
#: ../../source/chapters/24_searching/searching.rst:482
msgid "Create a List With All Items Matching a Property"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:360
msgid ""
"Another common operation is to grab all the items out of a list that match:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:362
msgid "get_matching_items"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:362
msgid ""
"def get_matching_items(my_list, key):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            matching_list.append(item)\n"
"    return matching_list"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:379
msgid "Full Example"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:381
msgid "For a full example, see below:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:383
msgid "linear_search_variations_2.py"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:383
msgid ""
"import random\n"
"\n"
"\n"
"def create_list(list_size):\n"
"    \"\"\" Create a list of random numbers \"\"\"\n"
"    my_list = []\n"
"\n"
"    for i in range(list_size):\n"
"        my_list.append(random.randrange(100))\n"
"\n"
"    return my_list\n"
"\n"
"\n"
"def check_if_one_item_has_property_v1(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    list_position = 0\n"
"    while list_position < len(my_list) and my_list[list_position] != key:\n"
"        list_position += 1\n"
"\n"
"    if list_position < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False\n"
"\n"
"\n"
"def check_if_one_item_has_property_v2(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            # Found an item that matched. Return True\n"
"            return True\n"
"\n"
"    # Went through the whole list. Return False.\n"
"    return False\n"
"\n"
"\n"
"def check_if_all_items_have_property(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item != key:\n"
"            # Found an item that didn't match. Return False.\n"
"            return False\n"
"\n"
"    # Got through the entire list. There were no mis-matches.\n"
"    return True\n"
"\n"
"\n"
"def get_matching_items(my_list, key):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            matching_list.append(item)\n"
"    return matching_list\n"
"\n"
"\n"
"def main():\n"
"\n"
"    # Create a list of 50 numbers\n"
"    my_list = create_list(50)\n"
"    print(my_list)\n"
"\n"
"    # Is at least one item zero?\n"
"    key = 0\n"
"    result = check_if_one_item_has_property_v1(my_list, 0)\n"
"    if result:\n"
"        print(\"At least one item in the list is\", key)\n"
"    else:\n"
"        print(\"No item in the list is\", key)\n"
"\n"
"    # Get items that match the key\n"
"    matching_list = get_matching_items(my_list, key)\n"
"    print(\"Matching items:\", matching_list)\n"
"\n"
"    # Are all items matching?\n"
"    result = check_if_all_items_have_property(my_list, key)\n"
"    print(\"All items in random list matching?\", result)\n"
"\n"
"    other_list = [0, 0, 0, 0, 0]\n"
"    result = check_if_all_items_have_property(other_list, key)\n"
"    print(\"All items in other list matching?\", result)\n"
"\n"
"\n"
"main()\n"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:390
msgid "Variations On The Linear Search With Objects"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:392
msgid ""
"For example, say we had a list of objects for our text adventure. We might "
"want to check that list and see if any of the items are in the same room as "
"our player. Or if all the items are. Or we might want to build a list of "
"items that the user is carrying if they are all in a \"special\" room that "
"represents the player's inventory."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:398
msgid "To begin with, we'd need to define our adventure object:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:400
msgid "Adventure Object class"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:400
msgid ""
"class AdventureObject:\n"
"    \"\"\" Class that defines an object in a text adventure game \"\"\"\n"
"\n"
"    def __init__(self, description, room):\n"
"        \"\"\" Constructor.\"\"\"\n"
"\n"
"        # Description of the object\n"
"        self.description = description\n"
"\n"
"        # The number of the room that the object is in\n"
"        self.room = room"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:419
msgid "Is at least one object in the specified room? We can check."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:421
msgid "Check if list has an item that has a property - ``while`` loop"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:421
msgid ""
"def check_if_one_item_is_in_room_v1(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    i = 0\n"
"    while i < len(my_list) and my_list[i].room != room:\n"
"        i += 1\n"
"\n"
"    if i < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:441
msgid ""
"This could also be done with a ``for`` loop. In this case, the loop will "
"exit early by using a ``return`` once the item has been found. The code is "
"shorter, but not every programmer would prefer it. Some programmers feel "
"that loops should not be prematurely ended with a ``return`` or ``break`` "
"statement. It all goes to personal preference, or the personal preference of"
" the person that is footing the bill."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:448
msgid "Check if list has an item that has a property - ``for`` loop"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:448
msgid ""
"def check_if_one_item_is_in_room_v2(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property. Works the same as v1, but less code.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            return True\n"
"    return False"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:465
msgid ""
"Are all the adventure objects in the same room? This code is very similar to"
" the prior example. Spot the difference and see if you can figure out the "
"reason behind the change."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:468
msgid "Check if all items have a property"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:468
msgid ""
"def check_if_all_items_are_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room != room:\n"
"            return False\n"
"    return True"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:484
msgid ""
"What if you wanted a list of objects that are in room 5? This is a "
"combination of our prior code, and the code to append items to a list that "
"we learned about back in :ref:`intro-to-lists`."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:488
msgid "Create another list with all items matching a property"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:488
msgid ""
"def get_items_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            matching_list.append(item)\n"
"    return matching_list"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:503
msgid ""
"How would you run all these in a test? The code above can be combined with "
"this code to run:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:506
msgid "Run Sample Functions"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:506
msgid ""
"def main():\n"
"    object_list = []\n"
"    object_list.append(AdventureObject(\"Key\", 5))\n"
"    object_list.append(AdventureObject(\"Bear\", 5))\n"
"    object_list.append(AdventureObject(\"Food\", 8))\n"
"    object_list.append(AdventureObject(\"Sword\", 2))\n"
"    object_list.append(AdventureObject(\"Wand\", 10))\n"
"\n"
"    result = check_if_one_item_has_property_v1(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_has_property_v1:\", result)\n"
"\n"
"    result = check_if_one_item_has_property_v2(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_has_property_v2:\", result)\n"
"\n"
"    result = check_if_all_items_have_property(object_list, 5)\n"
"    print(\"Result of test check_if_all_items_have_property:\", result)\n"
"\n"
"    result = get_matching_items(object_list, 5)\n"
"    print(\"Number of items returned from test get_matching_items:\", len(result))\n"
"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:533
msgid "For a full working example:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:535
msgid "linear_search_variations.py"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:535
msgid ""
"class AdventureObject:\n"
"    \"\"\" Class that defines an alien\"\"\"\n"
"\n"
"    def __init__(self, description, room):\n"
"        \"\"\" Constructor. Set name and color\"\"\"\n"
"        self.description = description\n"
"        self.room = room\n"
"\n"
"\n"
"def check_if_one_item_is_in_room_v1(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    i = 0\n"
"    while i < len(my_list) and my_list[i].room != room:\n"
"        i += 1\n"
"\n"
"    if i < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False\n"
"\n"
"\n"
"def check_if_one_item_is_in_room_v2(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property. Works the same as v1, but less code.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            return True\n"
"    return False\n"
"\n"
"\n"
"def check_if_all_items_are_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room != room:\n"
"            return False\n"
"    return True\n"
"\n"
"\n"
"def get_items_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            matching_list.append(item)\n"
"    return matching_list\n"
"\n"
"\n"
"def main():\n"
"    object_list = []\n"
"    object_list.append(AdventureObject(\"Key\", 5))\n"
"    object_list.append(AdventureObject(\"Bear\", 5))\n"
"    object_list.append(AdventureObject(\"Food\", 8))\n"
"    object_list.append(AdventureObject(\"Sword\", 2))\n"
"    object_list.append(AdventureObject(\"Wand\", 10))\n"
"\n"
"    result = check_if_one_item_is_in_room_v1(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_is_in_room_v1:\", result)\n"
"\n"
"    result = check_if_one_item_is_in_room_v2(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_is_in_room_v2:\", result)\n"
"\n"
"    result = check_if_all_items_are_in_room(object_list, 5)\n"
"    print(\"Result of test check_if_all_items_are_in_room:\", result)\n"
"\n"
"    result = get_items_in_room(object_list, 5)\n"
"    print(\"Number of items returned from test get_items_in_room:\", len(result))\n"
"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:540
msgid ""
"These common algorithms can be used as part of a solution to a larger "
"problem, such as find all the addresses in a list of customers that aren't "
"valid."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:546
msgid "Binary Search"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:552
msgid ""
"A faster way to search a list is possible with the binary search. The "
"process of a binary search can be described by using the classic number "
"guessing game \"guess a number between 1 and 100\" as an example. To make it"
" easier to understand the process, let's modify the game to be \"guess a "
"number between 1 and 128.\" The number range is inclusive, meaning both 1 "
"and 128 are possibilities."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:559
msgid ""
"If a person were to use the linear search as a method to guess the secret "
"number, the game would be rather long and boring."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:562
msgid ""
"Guess a number 1 to 128: 1\n"
"Too low.\n"
"Guess a number 1 to 128: 2\n"
"Too low.\n"
"Guess a number 1 to 128: 3\n"
"Too low.\n"
"....\n"
"Guess a number 1 to 128: 93\n"
"Too low.\n"
"Guess a number 1 to 128: 94\n"
"Correct!"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:576
msgid ""
"Most people will use a binary search to find the number. Here is an example "
"of playing the game using a binary search:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:578
msgid ""
"Guess a number 1 to 128: 64\n"
"Too low.\n"
"Guess a number 1 to 128: 96\n"
"Too high.\n"
"Guess a number 1 to 128: 80\n"
"Too low.\n"
"Guess a number 1 to 128: 88\n"
"Too low.\n"
"Guess a number 1 to 128: 92\n"
"Too low.\n"
"Guess a number 1 to 128: 94\n"
"Correct!"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:593
msgid ""
"Each time through the rounds of the number guessing game, the guesser is "
"able to eliminate one half of the problem space by getting a \"high\" or "
"\"low\" as a result of the guess."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:597
msgid ""
"In a binary search, it is necessary to track an upper and a lower bound of "
"the list that the answer can be in. The computer or number-guessing human "
"picks the midpoint of those elements. Revisiting the example:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:601
msgid ""
"A lower bound of 1, upper bound of 128, mid point of "
":math:`\\frac{128+1}{2}=64.5`."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:604
msgid ""
"Guess a number 1 to 128: 64\n"
"Too low."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:609
msgid ""
"A lower bound of 65, upper bound of 128, mid point of "
":math:`\\frac{65+128}{2}=96.5`."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:612
msgid ""
"Guess a number 1 to 128: 96\n"
"Too high."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:617
msgid ""
"A lower bound of 65, upper bound of 95, mid point of "
":math:`\\frac{65+95}{2}=80`."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:620
msgid ""
"Guess a number 1 to 128: 80\n"
"Too low."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:625
msgid ""
"A lower bound of 81, upper bound of 95, mid point of "
":math:`\\frac{81+95}{2}=88`."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:628
msgid ""
"Guess a number 1 to 128: 88\n"
"Too low."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:633
msgid ""
"A lower bound of 89, upper bound of 95, mid point of "
":math:`\\frac{89+95}{2}=92`."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:636
msgid ""
"Guess a number 1 to 128: 92\n"
"Too low."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:641
msgid ""
"A lower bound of 93, upper bound of 95, mid point of "
":math:`\\frac{93+95}{2}=94`."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:644
msgid ""
"Guess a number 1 to 128: 94\n"
"Correct!"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:649
msgid ""
"A binary search requires significantly fewer guesses. Worst case, it can "
"guess a number between 1 and 128 in 7 guesses. One more guess raises the "
"limit to 256. 9 guesses can get a number between 1 and 512. With just 32 "
"guesses, a person can get a number between 1 and 4.2 billion."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:654
msgid ""
"To figure out how large the list can be given a certain number of guesses, "
"the formula works out like :math:`n=x^{g}` where :math:`n` is the size of "
"the list and :math:`g` is the number of guesses. For example:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:658
msgid ":math:`2^7=128` (7 guesses can handle 128 different numbers)"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:659
msgid ":math:`2^8=256`"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:660
msgid ":math:`2^9=512`"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:661
msgid ":math:`2^{32}=4,294,967,296`"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:664
msgid ""
"If you have the problem size, we can figure out the number of guesses using "
"the log function. Specifically, *log base 2*. If you don't specify a base, "
"most people will assume you mean the natural log with a base of :math:`e "
"\\approx 2.71828` which is not what we want. For example, using log base 2 "
"to find how many guesses:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:670
msgid ":math:`log_2 128 = 7`"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:671
msgid ":math:`log_2 65,536 = 16`"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:674
msgid ""
"Enough math! Where is the code? The code to do a binary search is more "
"complex than a linear search:"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:677
msgid "Binary search"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:677
msgid ""
"# --- Binary search\n"
"key = \"Morgiana the Shrew\"\n"
"lower_bound = 0\n"
"upper_bound = len(name_list)-1\n"
"found = False\n"
"\n"
"# Loop until we find the item, or our upper/lower bounds meet\n"
"while lower_bound <= upper_bound and not found:\n"
"\n"
"    # Find the middle position\n"
"    middle_pos = (lower_bound + upper_bound) // 2\n"
"\n"
"    # Figure out if we:\n"
"    # move up the lower bound, or\n"
"    # move down the upper bound, or\n"
"    # we found what we are looking for\n"
"    if name_list[middle_pos] < key:\n"
"        lower_bound = middle_pos + 1\n"
"    elif name_list[middle_pos] > key:\n"
"        upper_bound = middle_pos - 1\n"
"    else:\n"
"        found = True\n"
"\n"
"if found:\n"
"    print( \"The name is at position\", middle_pos)\n"
"else:\n"
"    print( \"The name was not in the list.\" )"
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:709
msgid ""
"Since lists start at element zero, line 3 sets the lower bound to zero. Line"
" 4 sets the upper bound to the length of the list minus one. So for a list "
"of 100 elements the lower bound will be 0 and the upper bound 99."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:713
msgid ""
"The Boolean variable on line 5 will be used to let the while loop know that "
"the element has been found."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:716
msgid ""
"Line 8 checks to see if the element has been found or if we've run out of "
"elements. If we've run out of elements the lower bound will end up equaling "
"the upper bound."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:720
msgid ""
"Line 11 finds the middle position. It is possible to get a middle position "
"of something like 64.5. It isn't possible to look up position 64.5. "
"(Although J.K. Rowling was rather clever in enough coming up with Platform "
":math:`9\\frac{3}{4}`, that doesn't work here.) The best way of handling "
"this is to use the ``//`` operator first introduced way back in Chapter 1. "
"This is similar to the ``/`` operator, but will only return integer results."
" For example, ``11 // 2`` would give 5 as an answer, rather than 5.5."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:728
msgid ""
"Starting at line 17, the program checks to see if the guess is high, low, or"
" correct. If the guess is low, the lower bound is moved up to just past the "
"guess. If the guess is too high, the upper bound is moved just below the "
"guess. If the answer has been found, ``found`` is set to ``True`` ending the"
" search."
msgstr ""

#: ../../source/chapters/24_searching/searching.rst:734
msgid ""
"With the a list of 100 elements, a person can reasonably guess that on "
"average with the linear search, a program will have to check 50 of them "
"before finding the element. With the binary search, on average you'll still "
"need to do about seven guesses. In an advanced algorithms course you can "
"find the exact formula. For this course, just assume average and worst cases"
" are the same."
msgstr ""
