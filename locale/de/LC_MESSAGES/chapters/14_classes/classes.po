# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Paul Vincent Craven
# This file is distributed under the same license as the Arcade package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
# derSuessmann <arcade-book-de@dersuessmann.de>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Arcade Fall 2018\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-02 14:54-0600\n"
"PO-Revision-Date: 2019-07-14 19:34+0200\n"
"Last-Translator: derSuessmann <arcade-book-de@dersuessmann.de>\n"
"Language: de\n"
"Language-Team: German <arcade-book-de@dersuessmann.de>\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/chapters/14_classes/classes.rst:2
msgid "Classes, Constructors, and Attributes"
msgstr ""

#, fuzzy
msgid ""
".. image:: chapters\\14_classes\\../../images/video.svg\n"
"   :alt: Video link"
msgstr ".. image:: chapters/14_classes/dog_2_1.png"

#: ../../source/chapters/14_classes/classes.rst:9
msgid "Video: https://youtu.be/7BfXwcapLFQ"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:10
msgid ""
"Slides: https://slides.com/paulcraven/14-classes-constructors-and-"
"attributes/"
msgstr ""

#, fuzzy
msgid ".. image:: chapters\\14_classes\\construction.svg"
msgstr ".. image:: chapters/14_classes/one_person.png"

#: ../../source/chapters/14_classes/classes.rst:16
msgid ""
"Throughout this course we've been using variables to store *a* value. We "
"just learned how to store *multiple* values using a list. The next step "
"is **object-oriented programming**. This type of programming has three "
"advantages. One, we can group multiple variables together in a single "
"record. Two, we can associate functions with that group of data. Three, "
"we can use something called **inheritance** which allows us to take a "
"base set of code and extend it, without needing to rewrite it from "
"scratch."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:26
msgid "Using Classes and Objects to Group Data"
msgstr ""

#, fuzzy
msgid ".. image:: chapters\\14_classes\\character.svg"
msgstr ".. image:: chapters/14_classes/person_1.png"

#: ../../source/chapters/14_classes/classes.rst:32
msgid ""
"Grouping related data together using object-oriented programming can "
"simplify our code. For example, think of an adventure game. Each "
"character in an adventure game needs data, such as a name, what they look"
" like, how many hit points they have, their armor, and how fast they can "
"move."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:39
#, fuzzy
msgid ""
"Without classes, our Python code to store the information might look like"
" this:"
msgstr ""
"Ohne Klassen könnte der Python-Code, um diese Daten zu speichern, so "
"aussehen:"

#: ../../source/chapters/14_classes/classes.rst:42
#, fuzzy
msgid ""
"name = \"Link\"\n"
"outfit = \"Green\"\n"
"max_hit_points = 50\n"
"current_hit_points = 50\n"
"armor_amount = 6\n"
"max_speed = 10"
msgstr ""
"name = \"Link\"\n"
"outfit = \"Green\"\n"
"max_hit_points = 50\n"
"current_hit_points = 50"

#: ../../source/chapters/14_classes/classes.rst:52
#, fuzzy
msgid ""
"In order to do anything with this character, we'll need to pass all that "
"data to a function. With so many parameters, that function gets complex "
"and hard to manage."
msgstr ""
"Um irgendetwas mit diesem Charakter zu machen, müssen wir diese Daten an "
"eine Funktion übergeben:"

#: ../../source/chapters/14_classes/classes.rst:55
#, fuzzy
msgid ""
"def display_character(name, outfit, max_hit_points, current_hit_points, "
"armor, max_speed):\n"
"    print(name, outfit, max_hit_points, current_hit_points)"
msgstr ""
"name = \"Link\"\n"
"outfit = \"Green\"\n"
"max_hit_points = 50\n"
"current_hit_points = 50\n"
"max_speed = 10\n"
"\n"
"def display_character(name, outfit, max_hit_points, current_hit_points, "
"max_speed):\n"
"    print(name, sex, max_hit_points, current_hit_points)"

#: ../../source/chapters/14_classes/classes.rst:61
msgid ""
"As our game expands, we might start adding more character attributes, "
"such as weapons, magic, special abilities, and more. To do that we'd have"
" to go through each function in our program that works with the player "
"character and redo the parameters."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:66
msgid ""
"Keeping all these data points organized becomes difficult very quickly. "
"How do we keep a monster's hit points separated from the player's hit "
"points? Because when we add monsters to the game, they'll have their own "
"attributes. In fact, just about every item in an adventure game has "
"attributes."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:73
msgid ""
"There needs to be a better way. Somehow our program needs to package up "
"all those data fields for easy management."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:77
msgid "Defining Classes"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:79
msgid ""
"A better way to manage multiple data attributes is to define a structure "
"to hold the information. We can give that \"grouping\" of information a "
"name, like *Character* or *Address*. This can be easily done in Python "
"and any other modern language by using a **class**. Each data item we "
"group into the class is called a **field**, **attribute**, or **instance "
"variable**. These terms may be used interchangeably, as they mean the "
"same thing."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:89
msgid "Defining the Class"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:91
msgid ""
"Let's code an example using our adventure character. First, we tell the "
"computer we are defining a class with the ``class`` keyword, and then we "
"give the class a name that starts with a capital letter. Just like with "
"functions and loops, we end the statement with a colon, and everything "
"associated with the class will be indented below it:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:97
msgid "class Character:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:102
msgid ""
"Unlike variables, all class names should start with a capital letter. "
"While you *can* use a lower-case variable, you never should. Following "
"this pattern of lower-case for variables and upper-case for classes makes"
" it easy to tell which is which."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:107
msgid ""
"Next, we normally put into triple-quote comments a description of the "
"class."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:109
msgid ""
"class Character:\n"
"    \"\"\"\n"
"    This is a class that represents the player character.\n"
"    \"\"\""
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:117
msgid ""
"Yes, the code will run fine without any comments. It is optional. However"
" good documentation is important to maintainable code, even if you are "
"the only person using the code."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:121
msgid ""
"The cool feature about creating comments this way, is the text can be "
"pulled out automatically to form a website for your API documentation. "
"All the classes and functions in the Arcade library's API are created "
"with these comments. You can see the result here:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:127
msgid "https://arcade.academy/arcade.html"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:129
msgid ""
"For each of those examples, you can click on the \"source\" link and "
"quickly go to the source code for that function or class."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:135
msgid "Defining the Init Function"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:137
msgid ""
"Any time we create a new instance of a class, we need code that will "
"create our attributes (variables) and set them to default values. In "
"Python, this is the ``__init__`` method."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:141
msgid "This strangely named method needs a bit of explanation."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:143
msgid ""
"First, any function in a class is called a **method**, rather than a "
"function. This helps us keep straight what is in a class, and what isn't."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:146
msgid ""
"Second, the initialization method is a **magic method** that is called "
"automatically. Yes, Python programmers actually call methods that are "
"automatically invoked \"magic methods.\""
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:150
msgid ""
"Third, to signify a method is magic, Python surrounds the method name "
"with double underscores. Two underscores in the front, and two "
"underscores in the back. The short-name for double-underline is "
"**dunder**, and these magic methods are also known as **dunder methods**."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:155
#, fuzzy
msgid ""
"class Character:\n"
"    \"\"\"\n"
"    This is a class that represents the player character.\n"
"    \"\"\"\n"
"    def __init__(self):\n"
"        \"\"\" This is a method that sets up the variables in the object."
" \"\"\""
msgstr ""
"class Character():\n"
"    \"\"\" This is a class that represents the main character in a game. "
"\"\"\"\n"
"    def __init__(self):\n"
"        \"\"\" This is a method that sets up the variables in the object."
" \"\"\"\n"
"        self.name = \"\"\n"
"        outfit = \"Green\"\n"
"        self.max_hit_points = 0\n"
"        self.current_hit_points = 0\n"
"        self.max_speed = 0\n"
"        self.armor_amount = 0"

#: ../../source/chapters/14_classes/classes.rst:165
msgid ""
"The most common mistakes people make when typing this in is to use only "
"one underscore before and after the ``init``, and to forget that there is"
" a space between ``def`` and the first underscore."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:169
msgid ""
"All methods in a class have at least one parameter, and the first "
"parameter is always ``self``. We'll explain about ``self`` in the next "
"section."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:175
msgid "Defining Class Attributes"
msgstr ""

#, fuzzy
msgid ".. image:: chapters\\14_classes\\healthbar.png"
msgstr ".. image:: chapters/14_classes/example1.png"

#: ../../source/chapters/14_classes/classes.rst:182
msgid ""
"Remember back to our chapter on functions, that any variable created "
"inside a function is forgotten about after the function is done running? "
"If you want to keep anything, you need to return it as a value."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:186
msgid ""
"Methods follow this rule too, with one exception. The ``self`` parameter "
"refers to memory associated with each instance of the class. We can use "
"that ``self`` to create variables that *keep* their value for as long as "
"the object exists. We call variables that exist as part of the class "
"either attributes, fields, or instance variables. The terms mean the same"
" thing. Attributes must be set to a default value. That value is often 0,"
" an empty string, or the special value ``None``."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:194
msgid ""
"class Character:\n"
"    \"\"\"\n"
"    This is a class that represents the player character.\n"
"    \"\"\"\n"
"    def __init__(self):\n"
"        \"\"\" This is a method that sets up the variables in the object."
" \"\"\"\n"
"        self.name = \"\"\n"
"        self.outfit = \"\"\n"
"        self.max_hit_points = 0\n"
"        self.current_hit_points = 0\n"
"        self.armor_amount = 0\n"
"        self.max_speed = 0"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:210
msgid ""
"In the example above, if we had failed to put ``self.`` in front, the "
"computer would completely forget about the variables once the "
"``__init__`` function was done."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:214
#, fuzzy
msgid ""
"Here's another example, we are defining a class called ``Address`` which "
"has attributes for each field of a US mailing address."
msgstr ""
"Hier ist ein anderes Beispiel. Wir *definieren* eine Klasse, die alle "
"Datenfelder einer Adresse enthält:"

#: ../../source/chapters/14_classes/classes.rst:217
#, fuzzy
msgid ""
"class Address:\n"
"    \"\"\" Hold all the fields for a mailing address. \"\"\"\n"
"    def __init__(self):\n"
"        \"\"\" Set up the address fields. \"\"\"\n"
"        self.name = \"\"\n"
"        self.line1 = \"\"\n"
"        self.line2 = \"\"\n"
"        self.city = \"\"\n"
"        self.state = \"\"\n"
"        self.zip = \"\""
msgstr ""
"class Address():\n"
"    \"\"\" Hold all the fields for a mailing address. \"\"\"\n"
"    def __init__(self):\n"
"        \"\"\" Set up the address fields. \"\"\"\n"
"        self.name = \"\"\n"
"        self.line1 = \"\"\n"
"        self.line2 = \"\"\n"
"        self.city = \"\"\n"
"        self.state = \"\"\n"
"        self.zip = \"\""

#: ../../source/chapters/14_classes/classes.rst:231
msgid ""
"In the code above, ``Address`` is the class name. The variables in the "
"class are the attributes."
msgstr ""

#, fuzzy
msgid "Constructor?"
msgstr "Konstruktoren"

#: ../../source/chapters/14_classes/classes.rst:236
msgid ""
"There is some debate about calling ``__init__`` a constructor. In some "
"languages a constructor is called *before* the computer sets aside memory"
" for the object. In Python the ``__init__`` method is actually called "
"*after* this happens. For our purposes, the distinction is not important."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:242
msgid ""
"The ``__init__`` is a special method that you may also hear referred to "
"as a **constructor**. If you are programming in other languages, the term"
" constructor is a generic term used to refer to whatever that language's "
"equivalent to the ``__init__`` method is."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:247
#, fuzzy
msgid ""
"The ``self.`` is kind of like the pronoun *my*. When inside the class "
"``Address`` we are talking about *my* name, *my* city, etc. We don't want"
" to use ``self.`` outside the class. Why? Because just like the pronoun "
"\"my,\" it means someone totally different when said by a different "
"person!"
msgstr ""
"Das ``self.`` ist so ähnlich wie das Pronomen *mein*. In der Klasse "
"``Address`` reden wir von *meinem* ``name``, *meiner* ``city`` und so "
"weiter. Wir wollen aber ``self.`` nicht außerhalb der Klassendefinition "
"für ``Address`` für den Zugriff auf ein Attribut von ``Address`` "
"verwenden. Warum? Weil es genau wie das Pronomen \"mein\" etwas komplett "
"unterschiedliches bedeutet, wenn es von verschiedenen Personen gesagt "
"wird!"

#: ../../source/chapters/14_classes/classes.rst:253
msgid "Creating Objects"
msgstr ""

#, fuzzy
msgid ".. image:: chapters\\14_classes\\address.svg"
msgstr ".. image:: chapters/14_classes/two_addresses.png"

#: ../../source/chapters/14_classes/classes.rst:259
msgid ""
"The class code *defines* a class but it does not actually create an "
"**instance** of one. The code told the computer what fields an address "
"has, but we don't actually have an address yet. We can define a class "
"without creating one just like we can define a function without calling "
"it."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:265
#, fuzzy
msgid "To create an instance of the ``Address`` class, we use the following code:"
msgstr "Erzeuge ein Exemplar der Klasse ``Address``"

#: ../../source/chapters/14_classes/classes.rst:267
msgid ""
"def main():\n"
"    # Create an address\n"
"    home_address = Address()"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:274
msgid ""
"We need a variable that will point to our address. In this case, we've "
"called it ``home_address``. We'll set that variable equal to the new "
"instance of the class we create. We create an new instance by using the "
"name of the class (Address), followed by parentheses. This will "
"\"magically\" call the ``__init__`` method which will set up "
"fields/attributes for the class."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:282
msgid ""
"In this case, ``Address`` is a class. It defines what an address looks "
"like. The ``home_address`` variable points to an **object**. An object is"
" an instance of a class. It is the actual address. As another example, "
"\"Human\" is a class, while \"Samantha\" and \"Pete\" are instances of "
"the class."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:287
msgid ""
"You can set the object's attributes using the dot operator. First, use "
"the variable that points to our object, immediately follow that with a "
"period, then the attribute name."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:291
msgid ""
"def main():\n"
"    # Create an address\n"
"    home_address = Address()\n"
"\n"
"    # Set the fields in the address\n"
"    home_address.name = \"John Smith\"\n"
"    home_address.line1 = \"701 N. C Street\"\n"
"    home_address.line2 = \"Carver Science Building\"\n"
"    home_address.city = \"Indianola\"\n"
"    home_address.state = \"IA\"\n"
"    home_address.zip = \"50125\""
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:306
msgid ""
"A second variable can be created that points to a completely different "
"instance of the ``Address`` class:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:309
msgid ""
"    # Create another address\n"
"    vacation_home_address = Address()\n"
"\n"
"    # Set the fields in the address\n"
"    vacation_home_address.name = \"John Smith\"\n"
"    vacation_home_address.line1 = \"1122 Main Street\"\n"
"    vacation_home_address.line2 = \"\"\n"
"    vacation_home_address.city = \"Panama City Beach\"\n"
"    vacation_home_address.state = \"FL\"\n"
"    vacation_home_address.zip = \"32407\"\n"
"\n"
"    print(\"The client's main home is in \" + home_address.city)\n"
"    print(\"His vacation home is in \" + vacation_home_address.city)"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:326
msgid ""
"Attributes are not limited to being simple strings and numbers! If you "
"have a class that represents a graph, you can store all the data points "
"in an attribute that is a list. Attributes can even be other objects. An "
"object that represents a player character in an adventure could have an "
"attribute with another object that represents a magical hat."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:334
msgid "Common Mistakes Creating Objects"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:336
msgid ""
"The first common mistake when creating an object is to forget the "
"parentheses:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:338
msgid ""
"# ERROR - Forgot the parentheses after Address\n"
"home_address = Address"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:344
msgid ""
"The terrible thing about this mistake is that the program won't stop or "
"give you an error. Try running the example we just created with the two "
"different addresses. Take out the parentheses. The program runs without "
"error, but both the vacation home and the home address say we are in "
"Panama City! That's because without the parentheses we don't create a new"
" address, we just use the same block of memory and write the new "
"information over the old, so everything points to the same address."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:352
#, fuzzy
msgid ""
"Another very common mistake when working with classes is to forget to "
"specify which instance of the class you want to work with. If only one "
"address is created, it is natural to assume the computer will know to use"
" that address you are talking about. This is not the case."
msgstr ""
"Ein häufiger Fehler beim Programmieren mit Klassen ist, das Objekt mit "
"dem man arbeiten will zu vergessen. Wenn nur eine Adresse erzeugt wird, "
"nimmt man natürlich an, dass der Rechner weiß, dass man über diese "
"Adresse spricht. Das ist aber nicht der Fall. Siehe das Beispiel unten:"

#: ../../source/chapters/14_classes/classes.rst:357
msgid "Take a look at this code:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:359
msgid ""
"class Address:\n"
"    def __init__(self):\n"
"        self.name = \"\"\n"
"        self.line1 = \"\"\n"
"        self.line2 = \"\"\n"
"        self.city = \"\"\n"
"        self.state = \"\"\n"
"        self.zip = \"\"\n"
"\n"
"def main():\n"
"    # Create an address\n"
"    my_address = Address()\n"
"\n"
"    # Alert! This does not set the address's name!\n"
"    name = \"Dr. Smith\"\n"
"\n"
"    # This doesn't set the name for the address either\n"
"    Address.name = \"Dr. Smith\"\n"
"\n"
"    # This runs, creates a new attribute but with the wrong name.\n"
"    my_address.naem = \"Dr. Smith\"\n"
"\n"
"    # This does work:\n"
"    my_address.name = \"Dr. Smith\"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:389
msgid ""
"This code will run without generating an exception, but it still isn't "
"correct. Line 15 creates a variable called ``name``, but it is completely"
" different than the name that is part of ``Address``. So we think we've "
"set the name, but we haven't."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:394
msgid ""
"Line 18 does refer to ``Address``, but not ``my_address``. Frustratingly "
"it runs without alerting us to an error, but the code isn't modifying "
"``my_address``. Instead it sets something called a static variable, which"
" we'll talk about later."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:399
msgid ""
"Think of it this way. If you are in a room of people, saying \"Age is "
"18\" is confusing. Saying \"Human's age is 18\" is also confusing. Saying"
" \"Sally's age is 18\" is ideal, because you are saying which instance of"
" human you are referring to. You have to do this with programming, even "
"if there is only one human in the room."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:405
msgid ""
"Another mistake is on line 22. That line also runs fine, but it creates a"
" new attribute called ``naem`` instead of setting the desired attribute "
"``name``."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:409
msgid "Using Objects in Functions"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:411
#, fuzzy
msgid ""
"Putting lots of data fields into a class makes it easy to pass data in "
"and out of a function. In this example, the function takes in an address "
"as a parameter and prints it out on the screen. It is not necessary to "
"pass parameters for each field of the address."
msgstr ""
"Steckt man viele Attribute in eine Klasse, wird es einfach, Daten in und "
"aus einer Funktion heraus zu geben. Im Code unten, übernimmt die Funktion"
" eine Adresse als Parameter und gibt sie auf dem Bildschirm aus. Es ist "
"nicht nötig, Argumente für jedes einzelne Attribut der Adresse zu "
"übergeben."

#: ../../source/chapters/14_classes/classes.rst:416
msgid "Passing in an object as a function parameter"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:416
#, fuzzy
msgid ""
"def print_address(address):\n"
"    \"\"\" Print an address to the screen \"\"\"\n"
"\n"
"    print(address.name)\n"
"    # If there is a line1 in the address, print it\n"
"    if len(address.line1) > 0:\n"
"        print(address.line1)\n"
"    # If there is a line2 in the address, print it\n"
"    if len(address.line2) > 0:\n"
"        print( address.line2 )\n"
"    print(address.city + \", \" + address.state + \" \" + address.zip)\n"
"\n"
"\n"
"def main():\n"
"    # ... code for creating home_address and vacation_home_address\n"
"    # goes here.\n"
"    print_address(home_address)\n"
"    print()\n"
"    print_address(vacation_home_address)\n"
"\n"
"\n"
"main()"
msgstr ""
"# Print an address to the screen\n"
"def print_address(address):\n"
"    print(address.name)\n"
"    # If there is a line1 in the address, print it\n"
"    if len(address.line1) > 0:\n"
"        print(address.line1)\n"
"    # If there is a line2 in the address, print it\n"
"    if len(address.line2) > 0:\n"
"        print( address.line2 )\n"
"    print(address.city + \", \" + address.state + \" \" + address.zip)\n"
"\n"
"\n"
"def main():\n"
"    print_address(home_address)\n"
"    print()\n"
"    print_address(vacation_home_address)\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/14_classes/classes.rst:447
#, fuzzy
msgid "Customizing the Constructor"
msgstr "Konstruktoren überschreiben"

#, fuzzy
msgid ".. image:: chapters\\14_classes\\dog.svg"
msgstr ".. image:: chapters/14_classes/dog_2_1.png"

#: ../../source/chapters/14_classes/classes.rst:453
msgid ""
"Take a look at this code, where we represent a dog using a class. "
"Unfortunately, there's a terrible problem with the code. When we create a"
" dog, the dog has no name. Dogs should have names! `Only horses in the "
"desert can have no name "
"<https://en.wikipedia.org/wiki/A_Horse_with_No_Name>`_."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:459
#, fuzzy
msgid ""
"class Dog():\n"
"    def __init__(self):\n"
"        \"\"\" Constructor \"\"\"\n"
"        self.name = \"\"\n"
"\n"
"\n"
"def main():\n"
"    # This creates the dog\n"
"    my_dog = Dog()\n"
"    print(f\"The dog's name is: {my_dog.name}\")\n"
"\n"
"\n"
"main()"
msgstr ""
"class Dog():\n"
"    def __init__(self):\n"
"        self.name = \"\"\n"
"\n"
"\n"
"def main():\n"
"    my_dog = Dog()\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/14_classes/classes.rst:477
msgid ""
"We can modify the code in our constructor to keep this from happening. "
"First, let's add a ``print`` statement to our ``__init__`` just to "
"demonstrate that it is really being called."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:481
msgid ""
"class Dog():\n"
"    def __init__(self):\n"
"        \"\"\" Constructor \"\"\"\n"
"        self.name = \"\"\n"
"        print(\"A new dog is born!\")\n"
"\n"
"\n"
"def main():\n"
"    # This creates the dog\n"
"    my_dog = Dog()\n"
"    print(f\"The dog's name is: {my_dog.name}\")"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:497
msgid "When the program is run, it will print this:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:499
msgid "A new dog is born!"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:503
#, fuzzy
msgid ""
"When a Dog object is created on line 10, the ``__init__`` function is "
"\"magically\" called and the message is printed to the screen."
msgstr ""
"Wenn in Zeile 8 ein ``Dog``-Objekt erstellt wird, wird automatisch die "
"Funktion ``__init__`` aufgerufen und die Nachricht auf dem Bildschirm "
"ausgegeben."

#: ../../source/chapters/14_classes/classes.rst:506
msgid ""
"We can add a parameter to our constructor, so that it requires us to pass"
" in a name for the dog. Try running this code."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:509
msgid ""
"class Dog():\n"
"    def __init__(self, new_name):\n"
"        \"\"\" Constructor \"\"\"\n"
"        self.name = new_name\n"
"        print(\"A new dog is born!\")\n"
"\n"
"\n"
"def main():\n"
"    # This creates the dog\n"
"    my_dog = Dog()\n"
"    print(f\"The dog's name is: {my_dog.name}\")\n"
"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:528
msgid "You should get an error that looks like:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:530
msgid ""
"File \"c:/my_project/test.py\", line 10, in main\n"
"  my_dog = Dog()\n"
"TypeError: __init__() missing 1 required positional argument: 'new_name'"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:536
msgid ""
"The computer is saying it is missing a value for the ``new_name`` "
"parameter. It won't let the dog be created without a name. We can fix "
"that up by adding a name when we create the dog."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:540
#, fuzzy
msgid ""
"class Dog():\n"
"    def __init__(self, new_name):\n"
"        \"\"\" Constructor \"\"\"\n"
"        self.name = new_name\n"
"        print(\"A new dog is born!\")\n"
"\n"
"\n"
"def main():\n"
"    # This creates the dog\n"
"    my_dog = Dog(\"Fluffy\")"
msgstr ""
"class Dog():\n"
"    def __init__(self):\n"
"        self.name = \"\"\n"
"\n"
"\n"
"def main():\n"
"    my_dog = Dog()\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/14_classes/classes.rst:555
msgid ""
"Notice in line 4 we take the value that was passed in as a parameter and "
"assign ``self.name`` to have that same value. Without this line, the "
"dog's name won't get set."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:559
msgid ""
"As programmers sometimes get tired of making up variable names, it is "
"completely normal to see code like this:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:562
#, fuzzy
msgid ""
"class Dog():\n"
"    def __init__(self, name):\n"
"        \"\"\" Constructor \"\"\"\n"
"        self.name = name\n"
"        print(\"A new dog is born!\")\n"
"\n"
"\n"
"def main():\n"
"    # This creates the dog\n"
"    my_dog = Dog(\"Fluffy\")\n"
"\n"
"\n"
"main()"
msgstr ""
"class Dog():\n"
"    def __init__(self):\n"
"        self.name = \"\"\n"
"\n"
"\n"
"def main():\n"
"    my_dog = Dog()\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/14_classes/classes.rst:580
msgid ""
"Though it may seem strange at first, we have two variables at work, not "
"one. The first variable is ``name``, and that variable is assigned as a "
"parameter when we call the ``Dog`` constructor. It goes away as soon as "
"the ``Dog`` constructor is done, and is forgotten about. The second "
"variable is ``self.name``, and that variable is complete different than "
"``name``. Its value will stay after the constructor is done."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:591
msgid "Address Class With Init Parameters"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:593
msgid ""
"Here's another example, this time with our ``Address`` class. We supply "
"the address attributes as part of our ``__init__`` when our address is "
"created."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:596
msgid ""
"class Address():\n"
"    def __init__(self, , line2, city, state, zip, country):\n"
"        self.line1 = line1\n"
"        self.line2 = line2\n"
"        self.city = city\n"
"        self.state = state\n"
"        self.zip = zip\n"
"        self.country = country\n"
"\n"
"\n"
"def main():\n"
"    # This creates the address\n"
"    my_address = Address(\"701 N. C Street\",\n"
"                         \"Carver Science Building\",\n"
"                         \"Indianola\",\n"
"                         \"IA\",\n"
"                         \"50125\",\n"
"                          \"USA)\n"
"\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:622
msgid "Typing Attributes"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:624
msgid ""
"It is possible to tell Python what *type* of data should be stored in a "
"class attribute. This allows a programmer to use a tool like ``mypy`` and"
" catch errors earlier in the development process."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:628
msgid ""
"In this example, we are adding a type definition to the ``name`` "
"attribute on line 3. We do this by following the variable name with a "
"colon, and adding ``str`` which is the abbreviation for the **string** "
"data type."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:632
#, fuzzy
msgid ""
"class Person:\n"
"    def __init__(self):\n"
"        self.name: str = \"A\"\n"
"\n"
"\n"
"mary = Person()\n"
"mary.name = 22"
msgstr ""
"class Dog():\n"
"    def __init__(self):\n"
"        self.name = \"\"\n"
"\n"
"\n"
"def main():\n"
"    my_dog = Dog()\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/14_classes/classes.rst:644
msgid ""
"By assigning a number to the ``name`` attribute on line 7, we are storing"
" the wrong kind of data. The program runs, but if we use the ``mypy`` "
"tool, it will give us an error saying we've made a mistake:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:648
msgid ""
"test.py:7: error: Incompatible types in assignment (expression has type "
"\"int\", variable has type \"str\")\n"
"Found 1 error in 1 file (checked 1 source file)"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:654
msgid ""
"Typing is great for large programs, and for programs where we want to "
"make sure to catch all the errors we can before shipping to customers."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:657
msgid ""
"As we are just learning programming, it can be distracting to try adding "
"typing to our programs at this stage. But we will be both looking and "
"using, other people's code which does use typing. Therefore it is "
"important to know what typing is, even if we don't need to use it "
"ourselves until later."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:666
msgid "Data Classes"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:668
msgid ""
"When creating a class and a constructor to define a set of fields, we end"
" up with code that looks like this:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:671
msgid ""
"class Address:\n"
"    def __init__(self,\n"
"                 name: str = \"\",\n"
"                 line1: str = \"\",\n"
"                 line2: str = \"\",\n"
"                 city: str = \"\",\n"
"                 state: str = \"\",\n"
"                 zip_code: str = \"\"\n"
"                 ):\n"
"        self.name: str = name\n"
"        self.line1: str = line1\n"
"        self.line2: str = line2\n"
"        self.city: str = city\n"
"        self.state: str = state\n"
"        self.zip_code: str = zip_code"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:690
msgid ""
"This code is repetitive, as we state the fields twice. If your "
"``__init__`` method is only going to take in data fields and assign "
"attribute values, you can simplify your code by using a **dataclass**."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:695
msgid ""
"Starting with Python 3.8, you can write the same thing using only this "
"code:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:697
msgid ""
"@dataclass\n"
"class Address:\n"
"    name: str = \"\"\n"
"    line1: str = \"\"\n"
"    line2: str = \"\"\n"
"    city: str = \"\"\n"
"    state: str = \"\"\n"
"    zip_code: str = \"\""
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:709
msgid "This makes the code a lot easier to both write, and to read."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:712
msgid "Static Variables"
msgstr ""

#, fuzzy
msgid ".. image:: chapters\\14_classes\\cat.svg"
msgstr ".. image:: chapters/14_classes/example1.png"

#: ../../source/chapters/14_classes/classes.rst:718
msgid ""
"Class attributes are also called instance variables because they can be "
"different for each instance of the class. If you have five instances of "
"the ``Dog`` class, each instance will have its own name."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:722
msgid ""
"In a few rare cases, we want to share data between *all* instances of a "
"class. In this example with a ``Cat`` class, we have a ``population`` "
"variable. This variable is *not* different for each cat."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:726
msgid ""
"class Cat:\n"
"    population = 0\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        Cat.population += 1\n"
"\n"
"def main():\n"
"    cat1 = Cat(\"Pat\")\n"
"    cat2 = Cat(\"Pepper\")\n"
"    cat3 = Cat(\"Pouncy\")\n"
"\n"
"    print(\"The cat population is:\", Cat.population)\n"
"\n"
"main()"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:746
msgid ""
"In this case we use ``Cat.population`` to keep track of our cat "
"population, and the program will print out the correct count of 3."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:749
msgid ""
"Variables that *don't* change for each instance of a class, are called "
"**class variables** or **static variables**. The terms mean the same "
"thing and can be used interchangeably."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:753
msgid ""
"You refer to a static variable by using the class name ``Cat`` rather "
"than any of the instance names like ``cat1``."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:756
msgid ""
"Static variables aren't used that often. The only reason we are "
"introducing them here is that it is not unusual for students to "
"accidentally use a static variable instead of an instance variable. In "
"fact, Python makes it a bit too easy to 'blend' the two concepts "
"together."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:761
msgid ""
"For example, we can also print a static variable not just by using the "
"class name, but also by using the instance name:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:764
msgid ""
"print(\"The cat population is:\", Cat.population)\n"
"print(\"The cat population is:\", cat1.population)"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:770
msgid ""
"When we are reading code and come across a variable like "
"``Cat.population``, we immediately know it is static. How? All class "
"names start with a capital letter, so ``Cat`` is a class. The only "
"attributes that we can refer to with a class, rather than an instance, "
"are static variables. So ``population`` must be static. If we use "
"``cat1.population``, a programmer reading that code might mistakenly "
"assume it is an instance variable rather than a static variable, so that "
"makes debugging really hard. To reduce confusion, always refer to static "
"variables using the class name."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:778
msgid ""
"In this example, I set population to 4, and each print statement says "
"population is 4. This is confusing because I set one variable and the "
"others change. If I just use ``Cat.population`` to refer to the "
"population, then I remove that confusion."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:782
msgid ""
"Cat.population = 4\n"
"print(\"The cat population is:\", Cat.population)\n"
"print(\"The cat population is:\", cat2.population)\n"
"print(\"The cat population is:\", cat1.population)"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:790
msgid ""
"Here's where it gets really wild. As we just saw, I can print a static "
"variable by referring to it with an instance, rather than by the class "
"name. I shouldn't, but I can."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:794
msgid "What if, instead of printing, I assign a value that way?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:796
msgid ""
"Cat.population = 4\n"
"cat3.population = 5\n"
"print(\"The cat population is:\", Cat.population)\n"
"print(\"The cat population is:\", cat1.population)\n"
"print(\"The cat population is:\", cat2.population)\n"
"print(\"The cat population is:\", cat3.population)"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:806
msgid ""
"In this case ``Cat.population``, ``cat1.population``, and "
"``cat2.population`` all refer to the same static variable. But once I "
"*assign* a value to ``cat3.population`` it creates a brand-new *instance*"
" variable. So all the other cats use the static population value, while "
"``cat3`` uses a new instance variable with the same exact name as the "
"static variable. The static variable is **shadowed** by the instance "
"variable. Therefore when we print ``cat3.population`` we get a 5. That "
"type of bug is *very* hard to find."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:813
msgid ""
"For our purposes, we won't need to use static variables, we only "
"introduce them so that you can better understand some confusing errors "
"people occasionally run into."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:817
msgid "Review"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:819
msgid ""
"In this chapter we learned how to bundle together several related data "
"items into a **class**. We call these **class attributes**, **instance "
"variables**, or **fields**. Each instance of a class is an **object**. "
"Functions defined in a class are called **methods**. A special **magic "
"method** called when an object is created is the ``__init__`` method, "
"which is used to set up instance variables and assign them their initial "
"values."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:826
msgid ""
"Inside the class we refer to instance variables by putting ``self.`` in "
"front of them, such as ``self.name``. Outside the class, we need to use a"
" variable that refers to the class, such as ``customer.name``."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:830
msgid "Using classes helps simplify our code. We can use classes to represent:"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:832
msgid "Characters in a video game, with attributes for health, speed, and armor."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:833
msgid "Graphs, with attributes for heading, size, and data."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:834
msgid "A customer order, with a list as an attribute for each item in the order."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:836
msgid ""
"**Data classes** can be used to make it easier to define a class with a "
"lot of attributes. **Typing** can be used to make sure we don't put the "
"wrong type of data in an attribute. **Static variables** are attributes "
"that don't change from object to object."
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:843
msgid "Review Questions"
msgstr "Wiederholungsfragen"

#: ../../source/chapters/14_classes/classes.rst:845
msgid "What are the three main advantages of object-oriented programming?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:846
msgid "What keyword is used to define a new class?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:847
#, fuzzy
msgid "All class names should start with an upper-case or lower-case letter?"
msgstr "Sollten Klassennamen mit einem Groß- oder Kleinbuchstaben beginnen?"

#: ../../source/chapters/14_classes/classes.rst:848
msgid ""
"Where do the comments for a class go? What kind of comments do you use? "
"Why is there a standard?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:850
msgid "What is the difference between a function and a method?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:851
msgid ""
"What three different terms can be used to refer to data that is tied to a"
" a class?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:853
msgid "What is a magic method?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:854
msgid "What is a dunder method?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:855
msgid ""
"All class methods should have start with the same parameter. What is that"
" parameter?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:857
msgid "What is the name of the method in a class where we define our attributes?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:858
msgid "When defining a class attribute, what needs to go right before it?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:859
msgid "What is a constructor?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:860
msgid "What is the difference between a class and an object?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:861
#, fuzzy
msgid "What are the common mistakes when creating instances (objects) of a class?"
msgstr "Wie nennt man ein Exemplar einer Klasse?"

#: ../../source/chapters/14_classes/classes.rst:862
msgid ""
"How can we make sure our attributes are assigned when the object is "
"created?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:863
msgid "What is the point of adding \"typing\" to a class?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:864
msgid "What is a data class?"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:865
#, fuzzy
msgid "What are static variables?"
msgstr "Wie nennt man Variablen eines Exemplars einer Klasse?"

#: ../../source/chapters/14_classes/classes.rst:868
msgid "Lab 6: Text Adventure"
msgstr ""

#: ../../source/chapters/14_classes/classes.rst:870
msgid ""
"In :ref:`lab-06`, you'll use a class to represent a room in an text "
"adventure. You'll use attributes to store the room description, and which"
" rooms are north, south, east and west of it. You'll use a list to store "
"all the rooms in your adventure."
msgstr ""

#~ msgid "Introduction to Classes"
#~ msgstr "Einführung in Klassen"

#~ msgid ""
#~ "Classes and objects are very powerful"
#~ " programming tools. They make programming"
#~ " easier. In fact, you are already "
#~ "familiar with the concept of classes "
#~ "and objects. A class is a "
#~ "\"classification\" of an object. Like "
#~ "\"person\" or \"image.\" An object is"
#~ " a particular instance of a class."
#~ " Like \"Mary\" is an instance of "
#~ "\"Person.\""
#~ msgstr ""
#~ "Klassen und Objekte sind sehr mächtige"
#~ " Programmierwerkzeuge. Sie vereinfachen die "
#~ "Programmierung. Genau genommen bist du "
#~ "bereits mit dem Konzept der Klassen "
#~ "und Objekte vertraut. Eine Klasse ist"
#~ " eine \"Klassifikation\" eines Objekts, wie"
#~ " \"Person\" oder \"Abbild\". Ein Objekt "
#~ "ist ein tatsächliches Exemplar einer "
#~ "Klasse, wie \"Maria\" ein Exemplar von"
#~ " \"Person\" ist."

#~ msgid ""
#~ "Objects have attributes, such as a "
#~ "person's name, height, and age. Objects"
#~ " also have methods. Methods define "
#~ "what an object can do, like run,"
#~ " jump, or sit."
#~ msgstr ""
#~ "Objekte haben Attribute, wie Name, Größe"
#~ " und Alter einer Person. Objekte "
#~ "haben auch Methoden. Methoden definieren "
#~ "was ein Objekt tun kann, wie "
#~ "rennen, springen oder sitzen."

#~ msgid "Why Learn About Classes?"
#~ msgstr "Warum soll ich etwas über Klassen lernen?"

#~ msgid ""
#~ "Each character in an adventure game "
#~ "needs data: a name, location, strength,"
#~ " are they raising their arm, what "
#~ "direction they are headed, etc. Plus "
#~ "those characters do things. They run,"
#~ " jump, hit, and talk."
#~ msgstr ""
#~ "Jeder Charakter in einem Adventure-Spiel"
#~ " benötigt Daten: Einen Namen, Position, "
#~ "Stärke, heben sie ihren Arm, in "
#~ "welche Richtung bewegen sie sich und "
#~ "so weiter. Dazu machen Charaktere Dinge."
#~ " Sie rennen, springen, schlagen zu "
#~ "und reden."

#~ msgid ""
#~ "def display_character(name, sex, max_hit_points, current_hit_points):\n"
#~ "    print(name, sex, max_hit_points, current_hit_points)"
#~ msgstr ""
#~ "def display_character(name, sex, max_hit_points, current_hit_points):\n"
#~ "    print(name, sex, max_hit_points, current_hit_points)"

#~ msgid ""
#~ "Now imagine creating a program that "
#~ "has a set of variables like that"
#~ " for each character, monster, and "
#~ "item in our game. Then we need "
#~ "to create functions that work with "
#~ "those items. We've now waded into "
#~ "a quagmire of data. All of a "
#~ "sudden this doesn't sound like fun "
#~ "at all."
#~ msgstr ""
#~ "Stelle dir jetzt vor ein Programm "
#~ "zu erstellen, das eine Menge von "
#~ "Variablen wie diese für jeden Charakter,"
#~ " Monster und Gegenstand in deinem "
#~ "Spiel hat. Dann müssen wir noch "
#~ "Funktionen schreiben, die mit diesen "
#~ "Elementen arbeiten. Wir sind jetzt in"
#~ " Sumpf von Daten gelaufen. Auf einmal"
#~ " klingt das nicht mehr nach Spaß."

#~ msgid ""
#~ "But wait, it gets worse! As our"
#~ " game expands, we may need to "
#~ "add new fields to describe our "
#~ "character. In this case we've added "
#~ "``max_speed``:"
#~ msgstr ""
#~ "Aber warte, es wird noch schlimmer! "
#~ "Während unser Spiel größer wird, müssen"
#~ " wir neue Datenfelder hinzufügen, um "
#~ "unseren Charakter zu beschreiben. In "
#~ "diesem Fall haben wir ``max_speed`` "
#~ "hinzugefügt:"

#~ msgid ""
#~ "In example above, there is only "
#~ "one function. But in a large video"
#~ " game, we might have hundreds of "
#~ "functions that deal with the main "
#~ "character. Adding a new field to "
#~ "help describe what a character has "
#~ "and can do would require us to "
#~ "go through each one of those "
#~ "functions and add it to the "
#~ "parameter list. That would be a "
#~ "lot of work. And perhaps we need"
#~ " to add ``max_speed`` to different "
#~ "types of characters like monsters. There"
#~ " needs to be a better way. "
#~ "Somehow our program needs to package "
#~ "up those data fields so they can"
#~ " be managed easily."
#~ msgstr ""
#~ "Im Beispiel oben gibt es nur eine"
#~ " Funktion, aber in einem großen "
#~ "Videospiel könnten wir Hunderte Funktionen,"
#~ " die den Hauptcharakter betreffen, "
#~ "existieren. Das Hinzufügen eines neuen "
#~ "Datenfelds, das beschreibt, was ein "
#~ "Charakter hat und tun kann, würde "
#~ "uns zwingen durch jede dieser Funktionen"
#~ " zu gehen und es zur Parameterliste"
#~ " hinzufügen. Das wäre eine Menge "
#~ "Arbeit. Vielleicht müssen wir ``max_speed``"
#~ " zu verschiedenen Charakteren wie Monstern"
#~ " hinzufügen. Es muss einen besseren "
#~ "Weg geben. Irgendwie muss unser Programm"
#~ " diese Datenfelder zusammenpacken, so dass"
#~ " sie sich einfach verwalten lassen."

#~ msgid "Defining and Creating Simple Classes"
#~ msgstr "Definieren und Erstellen einfacher Klassen"

#~ msgid ""
#~ "A better way to manage multiple "
#~ "data attributes is to *define* a "
#~ "structure that has all of the "
#~ "information. Then we can give that "
#~ "\"grouping\" of information a name, like"
#~ " *Character* or *Address*. This can "
#~ "be easily done in Python and any"
#~ " other modern language by using a "
#~ "*class*."
#~ msgstr ""
#~ "Ein besserer Weg mehrere Datenattribute "
#~ "zu handhaben, ist eine Struktur zu "
#~ "*definieren*, die all diese Information "
#~ "umfasst. Dann können wir dieser "
#~ "\"Gruppierung\" von Information einen Namen"
#~ " wie *Charakter* oder *Adresse* geben. "
#~ "Dies kann in Python und jeder "
#~ "anderen modernen Sprache durch Verwendung "
#~ "einer *Klasse* erreicht werden."

#~ msgid ""
#~ "For example, we can *define* a "
#~ "class representing a character in a "
#~ "game:"
#~ msgstr ""
#~ "Zum Beispiel können wir eine Klasse, "
#~ "die einen Charakter im Spiel "
#~ "repräsentiert, *definieren*:"

#~ msgid "Define an address class"
#~ msgstr "Definiere eine Adress-Klasse"

#~ msgid ""
#~ "In the code above, ``Address`` is "
#~ "the class name. The variables in "
#~ "the class, such as ``name`` and "
#~ "``city``, are called *attributes* or "
#~ "*fields*. (Note the similarities and "
#~ "differences between declaring a class "
#~ "and declaring a function.)"
#~ msgstr ""
#~ "Im Beispiel oben ist ``Address`` der "
#~ "Klassenname. Die Variablen in der "
#~ "Klasse, wie ``name`` und ``city``, "
#~ "werden *Attribute* oder *Felder* genannt. "
#~ "(Beachte die Ähnlichkeiten und Unterschiede"
#~ " zwischen der Deklaration einer Klasse "
#~ "und einer Funktion.)"

#~ msgid ""
#~ "Unlike functions and variables, class "
#~ "names should begin with an upper "
#~ "case letter. While it is possible "
#~ "to begin a class with a lower "
#~ "case letter, it is not considered "
#~ "good practice."
#~ msgstr ""
#~ "Anders als bei Funktionen und Variablen"
#~ " sollen Klassennamen immer mit einem "
#~ "Großbuchstaben anfangen. Auch wenn es "
#~ "möglich ist, einen Klassennamen mit "
#~ "einem Kleinbuchstaben anzufangen, gilt das "
#~ "als schlechter Stil."

#~ msgid ""
#~ "The ``def __init__(self):`` in a special"
#~ " function called a *constructor* that "
#~ "is run automatically when the class "
#~ "is created. We'll discuss the "
#~ "constructor more in a bit."
#~ msgstr ""
#~ "Die ``def __init__(self):`` ist eine "
#~ "spezielle Funktion, die *Konstruktor* genannt"
#~ " wird. Sie wird automatisch ausgeführt, "
#~ "wenn ein Objekt der Klasse erzeugt "
#~ "wird. Wir werden den Konstruktor in "
#~ "Kürze mehr besprechen."

#~ msgid ""
#~ "To better visualize classes and how "
#~ "they relate, programmers often make "
#~ "diagrams. A diagram for the Address "
#~ "class would look like the figure "
#~ "below. See how the class name is"
#~ " on top with the name of each"
#~ " attribute listed below. To the right"
#~ " of each attribute is the data "
#~ "type, such as string or integer."
#~ msgstr ""
#~ "Um zu verdeutlichen, wie Klassen "
#~ "aufgebaut sind und wie sie in "
#~ "Beziehung stehen, zeichnen Programmierer oft"
#~ " Diagramme. Ein Diagramm für die "
#~ "Adressklasse würde wie in der Abbildung"
#~ " unten aussehen. Der Klassenname steht "
#~ "oben und jedes Attribut wird unten "
#~ "aufgelistet. Rechts von jedem Attribut "
#~ "steht sein Datentyp, wie String oder "
#~ "Integer."

#~ msgid ".. image:: chapters/14_classes/address_example_3.png"
#~ msgstr ".. image:: chapters/14_classes/address_example_3.png"

#~ msgid "Class Diagram"
#~ msgstr "Klassendiagramm"

#~ msgid ""
#~ "The class code *defines* a class "
#~ "but it does not actually create an"
#~ " *instance* of one. The code told "
#~ "the computer what fields an address "
#~ "has and what the initial default "
#~ "values will be. We don't actually "
#~ "have an address yet though. We can"
#~ " define a class without creating one"
#~ " just like we can define a "
#~ "function without calling it. To create"
#~ " a class and set the fields, "
#~ "look at the example below:"
#~ msgstr ""
#~ "Der Klassen-Code *definiert* eine "
#~ "Klasse, aber er erzeugt nicht wirklich"
#~ " ein *Objekt* (Instanz) einer Klasse. "
#~ "Der Code hat dem Rechner gesagt, "
#~ "welche Datenfelder eine Adresse hat und"
#~ " was ihre Standardwerte sein werden. "
#~ "Wir haben bis jetzt noch keine "
#~ "Adresse. Wir können eine Klasse "
#~ "definieren, ohne ein Objekt davon zu "
#~ "erzeugen, genau wie wir eine Funktion"
#~ " definieren können, ohne sie aufzurufen."
#~ " Sieh dir das Beispiel unten an, "
#~ "wie man ein Objekt einer Klasse "
#~ "erzeugt und die Attribute setzt:"

#~ msgid ""
#~ "# Create an address\n"
#~ "home_address = Address()\n"
#~ "\n"
#~ "# Set the fields in the address\n"
#~ "home_address.name = \"John Smith\"\n"
#~ "home_address.line1 = \"701 N. C Street\"\n"
#~ "home_address.line2 = \"Carver Science Building\"\n"
#~ "home_address.city = \"Indianola\"\n"
#~ "home_address.state = \"IA\"\n"
#~ "home_address.zip = \"50125\""
#~ msgstr ""
#~ "# Create an address\n"
#~ "home_address = Address()\n"
#~ "\n"
#~ "# Set the fields in the address\n"
#~ "home_address.name = \"John Smith\"\n"
#~ "home_address.line1 = \"701 N. C Street\"\n"
#~ "home_address.line2 = \"Carver Science Building\"\n"
#~ "home_address.city = \"Indianola\"\n"
#~ "home_address.state = \"IA\"\n"
#~ "home_address.zip = \"50125\""

#~ msgid ""
#~ "An instance of the address class "
#~ "is created in line 2. Note how "
#~ "the class ``Address`` name is used, "
#~ "followed by parentheses. The variable "
#~ "name can be anything that follows "
#~ "normal naming rules."
#~ msgstr ""
#~ "Ein Exemplar der Klasse ``Address`` wird"
#~ " in Zeile 2 erzeugt. Beachte, wie "
#~ "der Klassenname ``Address`` gefolgt von "
#~ "zwei runden Klammern verwendet wird. Der"
#~ " Variablenname kann irgendetwas sein, das"
#~ " den normalen Regeln für Variablennamen "
#~ "folgt."

#~ msgid ""
#~ "To set the fields in the class,"
#~ " a program must use the dot "
#~ "operator. This operator is the period"
#~ " that is between the ``home_address`` "
#~ "and the field name. See how lines"
#~ " 5-10 use the dot operator to "
#~ "set each field value."
#~ msgstr ""
#~ "Ein Programm muss den Punktoperator "
#~ "verwenden, um auf die Attribute des "
#~ "Objekts zuzugreifen. Dieser Operator ist "
#~ "der Punkt zwischen ``home_address`` und "
#~ "dem Attributnamen. Siehe wie in den "
#~ "Zeilen 5-10 der Punktoperator verwendet "
#~ "wird, um jeden Attributwert zu setzen."

#~ msgid ""
#~ "class Address():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.line1 = \"\"\n"
#~ "        self.line2 = \"\"\n"
#~ "        self.city = \"\"\n"
#~ "        self.state = \"\"\n"
#~ "        self.zip = \"\"\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create an address\n"
#~ "    my_address = Address()\n"
#~ "\n"
#~ "    # Alert! This does not set the address's name!\n"
#~ "    name = \"Dr. Craven\"\n"
#~ "\n"
#~ "    # This doesn't set the name for the address either\n"
#~ "    Address.name = \"Dr. Craven\"\n"
#~ "\n"
#~ "    # This does work:\n"
#~ "    my_address.name = \"Dr. Craven\"\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Address():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.line1 = \"\"\n"
#~ "        self.line2 = \"\"\n"
#~ "        self.city = \"\"\n"
#~ "        self.state = \"\"\n"
#~ "        self.zip = \"\"\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create an address\n"
#~ "    my_address = Address()\n"
#~ "\n"
#~ "    # Alert! This does not set the address's name!\n"
#~ "    name = \"Dr. Craven\"\n"
#~ "\n"
#~ "    # This doesn't set the name for the address either\n"
#~ "    Address.name = \"Dr. Craven\"\n"
#~ "\n"
#~ "    # This does work:\n"
#~ "    my_address.name = \"Dr. Craven\"\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "A second address can be created "
#~ "and fields from both instances may "
#~ "be used. See the example below:"
#~ msgstr ""
#~ "Eine zweite Adresse kann erzeugt werden"
#~ " und die Attribute beider Objekte "
#~ "können verwendet werden. Siehe das "
#~ "Beispiel unten:"

#~ msgid "Working with two instances of address"
#~ msgstr "Arbeiten mit zwei Exemplaren der Adresse"

#~ msgid ""
#~ "class Address():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.line1 = \"\"\n"
#~ "        self.line2 = \"\"\n"
#~ "        self.city = \"\"\n"
#~ "        self.state = \"\"\n"
#~ "        self.zip = \"\"\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create an address\n"
#~ "    home_address = Address()\n"
#~ "\n"
#~ "    # Set the fields in the address\n"
#~ "    home_address.name = \"John Smith\"\n"
#~ "    home_address.line1 = \"701 N. C Street\"\n"
#~ "    home_address.line2 = \"Carver Science Building\"\n"
#~ "    home_address.city = \"Indianola\"\n"
#~ "    home_address.state = \"IA\"\n"
#~ "    home_address.zip = \"50125\"\n"
#~ "\n"
#~ "    # Create another address\n"
#~ "    vacation_home_address = Address()\n"
#~ "\n"
#~ "    # Set the fields in the address\n"
#~ "    vacation_home_address.name = \"John Smith\"\n"
#~ "    vacation_home_address.line1 = \"1122 Main Street\"\n"
#~ "    vacation_home_address.line2 = \"\"\n"
#~ "    vacation_home_address.city = \"Panama City Beach\"\n"
#~ "    vacation_home_address.state = \"FL\"\n"
#~ "    vacation_home_address.zip = \"32407\"\n"
#~ "\n"
#~ "    print(\"The client's main home is in \" + home_address.city)\n"
#~ "    print(\"His vacation home is in \" + vacation_home_address.city)\n"
#~ "\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Address():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.line1 = \"\"\n"
#~ "        self.line2 = \"\"\n"
#~ "        self.city = \"\"\n"
#~ "        self.state = \"\"\n"
#~ "        self.zip = \"\"\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create an address\n"
#~ "    home_address = Address()\n"
#~ "\n"
#~ "    # Set the fields in the address\n"
#~ "    home_address.name = \"John Smith\"\n"
#~ "    home_address.line1 = \"701 N. C Street\"\n"
#~ "    home_address.line2 = \"Carver Science Building\"\n"
#~ "    home_address.city = \"Indianola\"\n"
#~ "    home_address.state = \"IA\"\n"
#~ "    home_address.zip = \"50125\"\n"
#~ "\n"
#~ "    # Create another address\n"
#~ "    vacation_home_address = Address()\n"
#~ "\n"
#~ "    # Set the fields in the address\n"
#~ "    vacation_home_address.name = \"John Smith\"\n"
#~ "    vacation_home_address.line1 = \"1122 Main Street\"\n"
#~ "    vacation_home_address.line2 = \"\"\n"
#~ "    vacation_home_address.city = \"Panama City Beach\"\n"
#~ "    vacation_home_address.state = \"FL\"\n"
#~ "    vacation_home_address.zip = \"32407\"\n"
#~ "\n"
#~ "    print(\"The client's main home is in \" + home_address.city)\n"
#~ "    print(\"His vacation home is in \" + vacation_home_address.city)\n"
#~ "\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "Line 11 creates the first instance "
#~ "of ``Address``; line 22 creates the "
#~ "second instance. The variable ``home_address``"
#~ " points to the first instance and "
#~ "``vacation_home_address`` points to the "
#~ "second."
#~ msgstr ""
#~ "Zeile 11 erzeugt das erste Exemplar "
#~ "von ``Address`` und Zeile 22 erzeugt "
#~ "das zweite Exemplar. Die Variable "
#~ "``home_address`` zeigt auf das erste "
#~ "Exemplar und ``vacation_home_address`` zeigt "
#~ "auf das zweite."

#~ msgid ""
#~ "Lines 25-30 set the fields in this"
#~ " new class instance. Line 32 prints"
#~ " the city for the home address, "
#~ "because ``home_address`` appears before the"
#~ " dot operator. Line 33 prints the "
#~ "vacation address because ``vacation_home_address``"
#~ " appears before the dot operator."
#~ msgstr ""
#~ "In den Zeilen 25-30 werden die "
#~ "Attribute des neuen Exemplars der Klasse"
#~ " gesetzt. Zeile 32 gibt die Stadt "
#~ "der Heimatadresse aus, weil ``home_address``"
#~ " vor dem Punktoperator erscheint. Zeile "
#~ "33 gibt die Ferienadresse aus, weil "
#~ "``vacation_home_address`` vor dem Punktoperator "
#~ "steht."

#~ msgid ""
#~ "In the example Address is called "
#~ "the class because it defines a new"
#~ " classification for a data object. "
#~ "The variables ``home_address`` and "
#~ "``vacation_home_address`` refer to objects "
#~ "because they refer to actual instances"
#~ " of the class ``Address``. A simple"
#~ " definition of an object is that "
#~ "it is an instance of a class. "
#~ "Like \"Bob\" and \"Nancy\" are instances"
#~ " of a Human class."
#~ msgstr ""
#~ "Im Beispiel wird ``Address`` Klasse "
#~ "genannt, weil sie eine neue "
#~ "Klassifikation für das Datenobjekt definiert."
#~ " Die Variablen ``home_address`` und "
#~ "``vacation_home_address`` beziehen sich auf "
#~ "zwei tatsächliche Objekte der Klasse "
#~ "``Address``. Eine einfache Definition eines"
#~ " Objekts ist, dass es ein Exemplar"
#~ " einer Klasse ist, wie \"Bob\" und"
#~ " \"Nancy\" Exemplare der Menschen-Klasse"
#~ " sind."

#~ msgid ""
#~ "By using www.pythontutor.com_ we can "
#~ "`visualize the execution of the code`_"
#~ " (see below). There are three "
#~ "variables in play. One points to "
#~ "the class definition of ``Address``. The"
#~ " other two variables point to the "
#~ "different address objects and their "
#~ "data."
#~ msgstr ""
#~ "Auf www.pythontutor.com_ können wir unter "
#~ "`visualize the execution of the code`_"
#~ " (siehe unten) die Ausführung des "
#~ "Programms visualisieren lassen. Es gibt "
#~ "drei Variablen bei der Ausführung. Eine"
#~ " zeigt auf die Definition der Klasse"
#~ " ``Address``. Die anderen beiden Variablen"
#~ " zeigen auf die beiden verschiedenen "
#~ "Adressobjekte und ihre Daten."

#~ msgid "Two Addresses"
#~ msgstr "Zwei Adressen"

#~ msgid "Adding Methods to Classes"
#~ msgstr "Methoden zu Klassen hinzufügen"

#~ msgid ""
#~ "In addition to attributes, classes may"
#~ " have methods. A method is a "
#~ "function that exists inside of a "
#~ "class. Expanding the earlier example of"
#~ " a ``Dog`` class from the review "
#~ "problem 1 above, the code below "
#~ "adds a method for a dog barking."
#~ msgstr ""
#~ "Zusätzlich zu Attributen können Klassen "
#~ "Methoden haben. Eine Methode ist eine"
#~ " Funktion die innerhalb einer Klasse "
#~ "existiert. Der Code unten erweitert das"
#~ " frühere Beispiel der ``Dog``-Klasse aus"
#~ " dem Wiederholungsproblem 1 oben um "
#~ "eine Bellen-Methode."

#~ msgid ""
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        self.age = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.weight = 0\n"
#~ "\n"
#~ "    def bark(self):\n"
#~ "        print(\"Woof\")"
#~ msgstr ""
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        self.age = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.weight = 0\n"
#~ "\n"
#~ "    def bark(self):\n"
#~ "        print(\"Woof\")"

#~ msgid ""
#~ "The method definition is contained in"
#~ " lines 7-8 above. Method definitions "
#~ "in a class look almost exactly "
#~ "like function definitions. The big "
#~ "difference is the addition of a "
#~ "parameter ``self`` on line 7. The "
#~ "first parameter of any method in a"
#~ " class must be ``self``. This "
#~ "parameter is required even if the "
#~ "function does not use it."
#~ msgstr ""
#~ "Die Methode steht in den Zeilen "
#~ "7-8 oben. Definitionen von Methoden in"
#~ " einer Klasse sehen fast genau so "
#~ "aus wie Funktionsdefinitionen. Der große "
#~ "Unterschied ist der zusätzliche Parameter "
#~ "``self`` in Zeile 7. Der erste "
#~ "Parameter jeder Methode einer Klasse "
#~ "muss immer ``self`` sein. Dieser "
#~ "Parameter ist notwendig, auch wenn die"
#~ " Funktion ihn nicht verwendet."

#~ msgid ""
#~ "Here are the important items to "
#~ "keep in mind when creating methods "
#~ "for classes:"
#~ msgstr "Hier sind die wichtigen Punkte, wenn man Methoden für Klassen erstellt:"

#~ msgid "Attributes should be listed first, methods after."
#~ msgstr "Attribute sollten zuerst aufgeführt werden, die Methoden danach."

#~ msgid "The first parameter of any method must be self."
#~ msgstr "Der erste Parameter jeder Methode muss immer ``self`` sein."

#~ msgid "Method definitions are indented exactly one tab stop."
#~ msgstr "Methodendefinitionen werden genau einen Schritt eingerückt."

#~ msgid ""
#~ "Methods may be called in a manner"
#~ " similar to referencing attributes from "
#~ "an object. See the example code "
#~ "below."
#~ msgstr ""
#~ "Methoden können ähnlich wie Attribute "
#~ "eines Objekts aufgerufen werden. Sieh "
#~ "das Beispiel unten."

#~ msgid ""
#~ "my_dog = Dog()\n"
#~ "\n"
#~ "my_dog.name = \"Spot\"\n"
#~ "my_dog.weight = 20\n"
#~ "my_dog.age = 3\n"
#~ "\n"
#~ "my_dog.bark()"
#~ msgstr ""
#~ "my_dog = Dog()\n"
#~ "\n"
#~ "my_dog.name = \"Spot\"\n"
#~ "my_dog.weight = 20\n"
#~ "my_dog.age = 3\n"
#~ "\n"
#~ "my_dog.bark()"

#~ msgid ""
#~ "Line 1 creates the dog. Lines 3-5"
#~ " set the attributes of the object."
#~ " Line 7 calls the ``bark`` function."
#~ " Note that even through the ``bark``"
#~ " function has one parameter, ``self``, "
#~ "the call does not pass in "
#~ "anything. This is because the first "
#~ "parameter is assumed to be a "
#~ "reference to the dog object itself. "
#~ "Behind the scenes, Python makes a "
#~ "call that looks like:"
#~ msgstr ""
#~ "Zeile 1 erzeugt den Hund. In den"
#~ " Zeilen 3-5 werden die Attribute "
#~ "gesetzt. Zeile 7 ruft die Methode "
#~ "``bark`` auf. Beachte, dass obwohl "
#~ "``bark`` einen Parameter hat, beim "
#~ "Aufruf kein Argument übergeben wird. Die"
#~ " liegt daran, dass der erste "
#~ "Parameter als Referenz auf das "
#~ "``Dog``-Objekt selbst verwendet wird. Hinter"
#~ " den Kulissen ruft Python das Ganze"
#~ " so auf:"

#~ msgid ""
#~ "# Example, not actually legal\n"
#~ "Dog.bark(my_dog)"
#~ msgstr ""
#~ "# Example, not actually legal\n"
#~ "Dog.bark(my_dog)"

#~ msgid ""
#~ "If the ``bark`` function needs to "
#~ "make reference to any of the "
#~ "attributes, then it does so using "
#~ "the ``self`` reference variable. For "
#~ "example, we can change the ``Dog`` "
#~ "class so that when the dog barks,"
#~ " it also prints out the dog's "
#~ "name. In the code below, the name"
#~ " attribute is accessed using a dot"
#~ " operator and the ``self`` reference."
#~ msgstr ""
#~ "Wenn die ``bark``-Funktion auf eines der"
#~ " Attribute zugreifen will, dann verwendet"
#~ " sie die ``self``-Referenzvariable. So "
#~ "können wir zum Beispiel die Klasse "
#~ "``Dog`` so anpassen, dass sie, wenn "
#~ "er bellt, auch seinen Namen ausgibt. "
#~ "Im Code unten wird auf das "
#~ "Attribut ``name`` mit dem Punktoperator "
#~ "und die Referenz ``self`` zugegriffen."

#~ msgid ""
#~ "def bark(self):\n"
#~ "    print(\"Woof says\", self.name)"
#~ msgstr ""
#~ "def bark(self):\n"
#~ "    print(\"Woof says\", self.name)"

#~ msgid ""
#~ "Attributes are adjectives, and methods "
#~ "are verbs. The drawing for the "
#~ "class would look like Figure 12.3."
#~ msgstr ""
#~ "Attribute sind Adjektive und Methoden "
#~ "Verben. Eine Zeichnung der Klasse würde"
#~ " wie Abbildung 12.3 aussehen."

#~ msgid "Dog Class"
#~ msgstr "Klasse ``Dog``"

#~ msgid "Example: Ball Class"
#~ msgstr "Beispiel: Ball-Klasse"

#~ msgid ""
#~ "This example code could be used in"
#~ " Python/Arcade to draw a ball. Having"
#~ " all the parameters contained in a"
#~ " class makes data management easier. "
#~ "The diagram for the ``Ball`` class "
#~ "is shown in the figure below."
#~ msgstr ""
#~ "Dieser Beispielcode könnte in Python/Arcade"
#~ " verwendet werden, um einen Ball zu"
#~ " zeichnen. Dadurch, dass alle Parameter "
#~ "in einer Klasse gekapselt sind, wird "
#~ "die Datenverwaltung einfacher. Das Diagramm"
#~ " für die Klasse ``Ball`` ist in "
#~ "der Abbildung unten zu sehen."

#~ msgid ".. image:: chapters/14_classes/ball_2_1.png"
#~ msgstr ".. image:: chapters/14_classes/ball_2_1.png"

#~ msgid "Ball Class"
#~ msgstr "Ball-Klasse"

#~ msgid ""
#~ "class Ball():\n"
#~ "    def __init__(self):\n"
#~ "        # --- Class Attributes ---\n"
#~ "        # Ball position\n"
#~ "        self.x = 0\n"
#~ "        self.y = 0\n"
#~ "\n"
#~ "        # Ball's vector\n"
#~ "        self.change_x = 0\n"
#~ "        self.change_y = 0\n"
#~ "\n"
#~ "        # Ball size\n"
#~ "        self.size = 10\n"
#~ "\n"
#~ "        # Ball color\n"
#~ "        self.color = [255,255,255]\n"
#~ "\n"
#~ "    # --- Class Methods ---\n"
#~ "    def move(self):\n"
#~ "        self.x += self.change_x\n"
#~ "        self.y += self.change_y\n"
#~ "\n"
#~ "    def draw(self):\n"
#~ "        arcade.draw_circle_filled(self.x, self.y, "
#~ "self.size, self.color )"
#~ msgstr ""
#~ "class Ball():\n"
#~ "    def __init__(self):\n"
#~ "        # --- Class Attributes ---\n"
#~ "        # Ball position\n"
#~ "        self.x = 0\n"
#~ "        self.y = 0\n"
#~ "\n"
#~ "        # Ball's vector\n"
#~ "        self.change_x = 0\n"
#~ "        self.change_y = 0\n"
#~ "\n"
#~ "        # Ball size\n"
#~ "        self.size = 10\n"
#~ "\n"
#~ "        # Ball color\n"
#~ "        self.color = [255,255,255]\n"
#~ "\n"
#~ "    # --- Class Methods ---\n"
#~ "    def move(self):\n"
#~ "        self.x += self.change_x\n"
#~ "        self.y += self.change_y\n"
#~ "\n"
#~ "    def draw(self):\n"
#~ "        arcade.draw_circle_filled(self.x, self.y, "
#~ "self.size, self.color )"

#~ msgid ""
#~ "Below is the code that would go"
#~ " ahead of the main program loop "
#~ "to create a ball and set its "
#~ "attributes:"
#~ msgstr ""
#~ "Unten steht der Code, der vor die"
#~ " Hauptschleife kommen würde, um einen "
#~ "Ball zu erzeugen und seine Attribute "
#~ "zu setzen: "

#~ msgid ""
#~ "the_ball = Ball()\n"
#~ "the_ball.x = 100\n"
#~ "the_ball.y = 100\n"
#~ "the_ball.change_x = 2\n"
#~ "the_ball.change_y = 1\n"
#~ "the_ball.color = [255, 0, 0]"
#~ msgstr ""
#~ "the_ball = Ball()\n"
#~ "the_ball.x = 100\n"
#~ "the_ball.y = 100\n"
#~ "the_ball.change_x = 2\n"
#~ "the_ball.change_y = 1\n"
#~ "the_ball.color = [255, 0, 0]"

#~ msgid "This code would go inside the main loop to move and draw the ball:"
#~ msgstr ""
#~ "Dieser Code würde in die Hauptschleife"
#~ " kommen, um den Ball zu bewegen "
#~ "und zu zeichnen:"

#~ msgid ""
#~ "the_ball.move()\n"
#~ "the_ball.draw()"
#~ msgstr ""
#~ "the_ball.move()\n"
#~ "the_ball.draw()"

#~ msgid "References"
#~ msgstr "Referenzen"

#~ msgid ""
#~ "Here's where we separate the true "
#~ "programmers from the want-to-be's. "
#~ "Understanding class references. Take a "
#~ "look at the following code:"
#~ msgstr ""
#~ "Hier kommt das, was echte Programmierer"
#~ " von Möchte-Gern-Programmierern trennt: "
#~ "Klassenreferenzen zu verstehen. Sieh dir "
#~ "den folgenden Code an:"

#~ msgid ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.money = 0\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    bob = Person()\n"
#~ "    bob.name = \"Bob\"\n"
#~ "    bob.money = 100\n"
#~ "\n"
#~ "    nancy = Person()\n"
#~ "    nancy.name = \"Nancy\"\n"
#~ "\n"
#~ "    print(bob.name, \"has\", bob.money, \"dollars.\")\n"
#~ "    print(nancy.name, \"has\", nancy.money, \"dollars.\")\n"
#~ "\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.money = 0\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    bob = Person()\n"
#~ "    bob.name = \"Bob\"\n"
#~ "    bob.money = 100\n"
#~ "\n"
#~ "    nancy = Person()\n"
#~ "    nancy.name = \"Nancy\"\n"
#~ "\n"
#~ "    print(bob.name, \"has\", bob.money, \"dollars.\")\n"
#~ "    print(nancy.name, \"has\", nancy.money, \"dollars.\")\n"
#~ "\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "The code above creates two instances "
#~ "of the ``Person()`` class, and using "
#~ "`www.pythontutor.com`_ we can `visualize the"
#~ " two classes`_ in the figure."
#~ msgstr ""
#~ "Der Code oben erzeugt zwei Exemplare "
#~ "der Klasse ``Person`` und mit "
#~ "`www.pythontutor.com`_ können wir die zwei "
#~ "Klassen mit `visualize the two classes`_"
#~ " in der Abbildung visualisieren."

#~ msgid ".. image:: chapters/14_classes/two_persons.png"
#~ msgstr ".. image:: chapters/14_classes/two_persons.png"

#~ msgid "Two Persons"
#~ msgstr "Zwei Personen"

#~ msgid "The code above has nothing new. But the code below does:"
#~ msgstr "Der Code oben enthält nichts Neues, aber der Code unten schon:"

#~ msgid ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.money = 0\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    bob = Person()\n"
#~ "    bob.name = \"Bob\"\n"
#~ "    bob.money = 100\n"
#~ "\n"
#~ "    nancy = bob\n"
#~ "    nancy.name = \"Nancy\"\n"
#~ "\n"
#~ "    print(bob.name, \"has\", bob.money, \"dollars.\")\n"
#~ "    print(nancy.name, \"has\", nancy.money, \"dollars.\")\n"
#~ "\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.money = 0\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    bob = Person()\n"
#~ "    bob.name = \"Bob\"\n"
#~ "    bob.money = 100\n"
#~ "\n"
#~ "    nancy = bob\n"
#~ "    nancy.name = \"Nancy\"\n"
#~ "\n"
#~ "    print(bob.name, \"has\", bob.money, \"dollars.\")\n"
#~ "    print(nancy.name, \"has\", nancy.money, \"dollars.\")\n"
#~ "\n"
#~ "\n"
#~ "main()"

#~ msgid "See the difference on line 10?"
#~ msgstr "Siehst du den Unterschied in Zeile 10?"

#~ msgid ""
#~ "A common misconception when working with"
#~ " objects is to assume that the "
#~ "variable ``bob`` *is* the ``Person`` "
#~ "object. This is not the case. The"
#~ " variable ``bob`` is a *reference* to"
#~ " the ``Person`` object. That is, it"
#~ " stores the memory address of where"
#~ " the object is, and not the "
#~ "object itself."
#~ msgstr ""
#~ "Ein übliches Missverständnis, wenn man "
#~ "mit Objekten arbeitet, ist anzunehmen, "
#~ "dass die Variable ``bob`` das "
#~ "``Person``-Objekt *ist*. Das ist nicht "
#~ "der Fall. Die Variable ``bob`` ist "
#~ "eine ``Referenz`` (Verweis) auf das "
#~ "``Person``-Objekt. Das heißt, es speichert "
#~ "die Adresse wo sich das Objekt im"
#~ " Speicher befindet und nicht das "
#~ "Objekt selbst."

#~ msgid ""
#~ "If ``bob`` actually was the object, "
#~ "then line 9 could create a *copy*"
#~ " of the object and there would "
#~ "be two objects in existence. The "
#~ "output of the program would show "
#~ "both Bob and Nancy having 100 "
#~ "dollars. But when run, the program "
#~ "outputs the following instead:"
#~ msgstr ""
#~ "Wenn ``bob`` tatsächlich das Objekt "
#~ "wäre, würde Zeile 9 eine *Kopie* "
#~ "des Objekts erzeugen und es gäbe "
#~ "danach zwei Objekte. Das Programm würde"
#~ " sowohl für Bob und Nancy 100 "
#~ "Dollar ausgeben. Wenn das Programm "
#~ "abläuft, gibt es stattdessen das "
#~ "folgende aus:"

#~ msgid ""
#~ "Nancy has 100 dollars.\n"
#~ "Nancy has 100 dollars."
#~ msgstr ""
#~ "Nancy has 100 dollars.\n"
#~ "Nancy has 100 dollars."

#~ msgid ""
#~ "What ``bob`` stores is a *reference* "
#~ "to the object. Besides reference, one"
#~ " may call this *address*, *pointer*, "
#~ "or *handle*. A reference is an "
#~ "address in computer memory for where "
#~ "the object is stored. This address "
#~ "is a hexadecimal number which, if "
#~ "printed out, might look something like"
#~ " ``0x1e504``. When line 9 is run, "
#~ "the address is copied rather than "
#~ "the entire object the address points "
#~ "to. See the figure below."
#~ msgstr ""
#~ "Was ``bob`` speichert, ist eine "
#~ "*Referenz* auf das Objekt. Man kann "
#~ "statt Referenz dies auch *Adresse*, "
#~ "*Zeiger* oder *Handle* nennen. Eine "
#~ "Referenz ist die Adresse im Speicher "
#~ "des Rechners, an der das Objekt "
#~ "gespeichert ist. Diese Adresse ist eine"
#~ " hexadezimale Zahl, die, wenn man sie"
#~ " ausgibt, so ähnlich wie ``0x1e504`` "
#~ "aussieht. Wenn die Zeile 9 ausgeführt"
#~ " wird, wird nur die Adresse kopiert"
#~ " und nicht das gesamte Objekt, auf"
#~ " das die Adresse zeigt. Siehe die "
#~ "Abbildung unten."

#~ msgid "Class References"
#~ msgstr "Klassenreferenzen"

# Add link to pythontutor.com
#~ msgid ""
#~ "We can also run this in "
#~ "www.pythontutor.com to see how both of"
#~ " the variables `are pointing to the"
#~ " same object`_."
#~ msgstr ""
#~ "Wir können dies ebenfalls auf "
#~ "www.pythontutor.com ausführen um zu sehen, "
#~ "dass die Variablen `are pointing to "
#~ "the same object`_."

#~ msgid "One Person, Two Pointers"
#~ msgstr "Eine Person - zwei Zeiger"

#~ msgid "Functions and References"
#~ msgstr "Funktionen und Referenzen"

#~ msgid ""
#~ "Look at the code example below. "
#~ "Line 1 creates a function that "
#~ "takes in a number as a parameter."
#~ " The variable ``money`` is a variable"
#~ " that contains a copy of the "
#~ "data that was passed in. Adding "
#~ "100 to that number does not change"
#~ " the number that was stored in "
#~ "``bob.money`` on line 11. Thus, the "
#~ "print statement on line 14 prints "
#~ "out 100, and not 200."
#~ msgstr ""
#~ "Sieh dir das Codebeispiel unten an. "
#~ "Zeile 1 erzeugt eine Funktion, die "
#~ "eine Zahl als Parameter übernimmt. Die"
#~ " Variable ``money`` ist eine Variable, "
#~ "die eine Kopie der Daten enthält, "
#~ "die übergeben wurden. 100 zu der "
#~ "Zahl zu addieren verändert nicht die "
#~ "Zahl, die in ``bob.money`` in Zeile "
#~ "11 gespeichert wurde. Die ``print``-Anweisung"
#~ " gibt deshalb 100 statt 200 aus."

#~ msgid ""
#~ "def give_money1(money):\n"
#~ "    money += 100\n"
#~ "\n"
#~ "\n"
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.money = 0\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    bob = Person()\n"
#~ "    bob.name = \"Bob\"\n"
#~ "    bob.money = 100\n"
#~ "\n"
#~ "    give_money1(bob.money)\n"
#~ "    print(bob.money)\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "def give_money1(money):\n"
#~ "    money += 100\n"
#~ "\n"
#~ "\n"
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "        self.money = 0\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    bob = Person()\n"
#~ "    bob.name = \"Bob\"\n"
#~ "    bob.money = 100\n"
#~ "\n"
#~ "    give_money1(bob.money)\n"
#~ "    print(bob.money)\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "`Running on PythonTutor`_ we see that"
#~ " there are two instances of the "
#~ "``money`` variable. One is a copy "
#~ "and local to the give_money1 function."
#~ msgstr ""
#~ "`Running on PythonTutor`_ sehen wir, "
#~ "dass es zwei Exemplare der Variable "
#~ "``money`` gibt. Eine ist eine Kopie "
#~ "und lokal in der Funktion ``give_money``"
#~ " verfügbar."

#~ msgid ".. image:: chapters/14_classes/function_references_1.png"
#~ msgstr ".. image:: chapters/14_classes/function_references_1.png"

#~ msgid "Function References"
#~ msgstr "Funktionsreferenzen"

#~ msgid ""
#~ "Look at the additional code below. "
#~ "This code does cause ``bob.money`` to"
#~ " increase and the ``print`` statement "
#~ "to print 200."
#~ msgstr ""
#~ "Sieh dir den zusätzlichen Code unten "
#~ "an. Dieser Code sorgt dafür, dass "
#~ "sich ``bob.money`` erhöht und die "
#~ "``print``-Anweisung gibt 200 aus."

#~ msgid ""
#~ "def give_money2(person):\n"
#~ "    person.money += 100\n"
#~ "\n"
#~ "give_money2(bob)\n"
#~ "print(bob.money)"
#~ msgstr ""
#~ "def give_money2(person):\n"
#~ "    person.money += 100\n"
#~ "\n"
#~ "give_money2(bob)\n"
#~ "print(bob.money)"

#~ msgid ""
#~ "Why is this? Because ``person`` contains"
#~ " a copy of the memory address "
#~ "of the object, not the actual "
#~ "object itself. One can think of it"
#~ " as a bank account number. The "
#~ "function has a copy of the bank"
#~ " account number, not a copy of "
#~ "the whole bank account. So using "
#~ "the copy of the bank account "
#~ "number to deposit 100 dollars causes "
#~ "Bob's bank account balance to go "
#~ "up."
#~ msgstr ""
#~ "Warum ist das so? Weil ``person`` "
#~ "eine Kopie der Speicheradresse des "
#~ "Objekts und nicht das tatsächliche "
#~ "Objekt ist. Man kann sich das wie"
#~ " eine Kontonummer vorstellen. Die Funktion"
#~ " hat eine Kopie der Kontonummer und"
#~ " nicht eine Kopie des gesamten "
#~ "Bankkontos. So kann man die Kontonummer"
#~ " verwenden, um 100 Dollar auf Bobs"
#~ " Bankkonto zu überweisen und Bobs "
#~ "Bankguthaben erhöht sich um 100 Dollar."

#~ msgid ".. image:: chapters/14_classes/function_references_2.png"
#~ msgstr ".. image:: chapters/14_classes/function_references_2.png"

#~ msgid ""
#~ "Arrays work the same way. A "
#~ "function that takes in an array "
#~ "(list) as a parameter and modifies "
#~ "values in that array will be "
#~ "modifying the same array that the "
#~ "calling code created. The address of "
#~ "the array is copied, not the "
#~ "entire array."
#~ msgstr ""
#~ "Arrays funktionieren auf dieselbe Art. "
#~ "Eine Funktion, die ein Array (Liste) "
#~ "als Parameter übernimmt und die Werte"
#~ " in diesem Array verändert, wird das"
#~ " gleiche Array verwenden, das der "
#~ "aufrufende Code erzeugt hat. Die Adresse"
#~ " des Arrays wird kopiert und nicht"
#~ " das gesamte Array."

#~ msgid ""
#~ "Create a class called ``Cat``. Give "
#~ "it attributes for name, color, and "
#~ "weight. Give it a method called "
#~ "``meow``."
#~ msgstr ""
#~ "Erstelle eine Klasse ``Cat``. Gib ihr"
#~ " Attribute für Name, Farbe und "
#~ "Gewicht. Gib ihr eine Methode ``meow``"
#~ " genannt."

#~ msgid ""
#~ "Create an instance of the cat "
#~ "class, set the attributes, and call "
#~ "the ``meow`` method."
#~ msgstr ""
#~ "Erzeuge ein Exemplar der Klasse ``Cat``,"
#~ " setze die Attribute und rufe die "
#~ "Methode ``meow`` auf."

#~ msgid ""
#~ "Create a class called ``Monster``. Give"
#~ " it an attribute for name and "
#~ "an integer attribute for health. Create"
#~ " a method called ``decrease_health`` that"
#~ " takes in a parameter amount and "
#~ "decreases the health by that much. "
#~ "Inside that method, print that the "
#~ "animal died if health goes below "
#~ "zero."
#~ msgstr ""
#~ "Erstelle eine Klasse ``Monster``. Gib "
#~ "ihr ein Attribut für den Namen und"
#~ " ein Ganzzahl-Attribut für "
#~ "Gesundheitszustand. Erstelle eine Methode "
#~ "``decrease_health``, die einen Parameter "
#~ "``amount`` hat und das den "
#~ "Gesundheitszustand um diese Anzahl reduziert."
#~ " Gib in der Methode aus, dass "
#~ "das Tier gestorben ist, wenn der "
#~ "Gesundheitszustand kleiner als Null wird."

#~ msgid ""
#~ "There's a terrible problem with our "
#~ "class for Dog listed below. When "
#~ "we create a dog, by default the"
#~ " dog has no name. Dogs should "
#~ "have names! We should not allow "
#~ "dogs to be born and then never "
#~ "be given a name. Yet the code "
#~ "below allows this to happen, and "
#~ "that dog will never have a name."
#~ msgstr ""
#~ "Es gibt ein schreckliches Problem mit"
#~ " unserer Klasse ``Dog`` unten. Wenn "
#~ "wir einen Hund erzeugen, hat er "
#~ "standardmäßig keinen Namen. Hunde sollten "
#~ "Namen haben! Wir sollten nicht erlauben,"
#~ " dass ein Hund geworfen wird und "
#~ "niemals einen Namen bekommt. Der Code"
#~ " unten erlaubt dies jedoch und dieser"
#~ " Hund wird nie einen Namen bekommen."

#~ msgid ""
#~ "Python doesn't want this to happen. "
#~ "That's why Python classes have a "
#~ "special function that is called any "
#~ "time an instance of that class is"
#~ " created. By adding a function called"
#~ " a constructor, a programmer can add"
#~ " code that is automatically run each"
#~ " time an instance of the class "
#~ "is created. See the example constructor"
#~ " code below:"
#~ msgstr ""
#~ "Python möchte nicht, dass dies passiert."
#~ " Deshalb haben Python-Klassen eine "
#~ "spezielle Funktion, die immer aufgerufen "
#~ "wird, wenn ein Exemplar der Klasse "
#~ "erzeugt wird. Durch Hinzufügen einer "
#~ "Konstruktor genannten Funktion, kann ein "
#~ "Programmierer Code hinzufügen, der bei "
#~ "jeder Erstellung eines Exemplars der "
#~ "Klasse automatisch aufgerufen wird. Siehe "
#~ "den folgenden Beispiel-Konstruktorcode:"

#~ msgid "Example of a class with a constructor"
#~ msgstr "Beispiel einer Klasse mit Konstruktor"

#~ msgid ""
#~ "The constructor starts on line 2. "
#~ "It must be named ``__init__``. There "
#~ "are two underscores before the init, "
#~ "and two underscores after. A common "
#~ "mistake is to only use one."
#~ msgstr ""
#~ "Der Konstruktor beginnt in Zeile 2. "
#~ "Er muss ``__init__`` heißen. Es gibt "
#~ "zwei Unterstriche vor init und zwei "
#~ "danach. Ein üblicher Fehler ist nur "
#~ "einen zu schreiben."

#~ msgid ""
#~ "The constructor must take in self "
#~ "as the first parameter just like "
#~ "other methods in a class. When the"
#~ " program is run, it will print::"
#~ msgstr ""
#~ "Der Konstruktor muss ``self`` als ersten"
#~ " Parameter haben, genau wie alle "
#~ "anderen Methoden einer Klasse. Wenn das"
#~ " Programm ausgeführt wird, wird Folgendes"
#~ " ausgegeben:"

# There is something wrong. The formatting instruction is in the product.
#~ msgid ".. code-block:: text"
#~ msgstr ".. code-block:: text"

#~ msgid "A new dog is born!"
#~ msgstr "Ein neuer Hund wird geworfen!"

#~ msgid "Avoid This Mistake"
#~ msgstr "Vermeide diesen Fehler"

#~ msgid ""
#~ "Put everything for a method into "
#~ "just one definition. Don't define it "
#~ "twice. For example:"
#~ msgstr ""
#~ "Schreibe alles für eine Methode in "
#~ "eine Definition. Definiere es nicht "
#~ "zweimal. Zum Beispiel:"

#~ msgid ""
#~ "# Wrong:\n"
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        self.age = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.weight = 0\n"
#~ "\n"
#~ "    def __init__(self):\n"
#~ "        print(\"New dog!\")"
#~ msgstr ""
#~ "# Wrong:\n"
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        self.age = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.weight = 0\n"
#~ "\n"
#~ "    def __init__(self):\n"
#~ "        print(\"New dog!\")"

#~ msgid ""
#~ "The computer will just ignore the "
#~ "first ``__init__`` and go with the "
#~ "last definition. Instead do this:"
#~ msgstr ""
#~ "Der Computer ignoriert einfach das erste"
#~ " `` __init__`` und geht zur letzten"
#~ " Definition über. Schreibe stattdessen "
#~ "folgendes:"

#~ msgid ""
#~ "# Correct:\n"
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        self.age = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.weight = 0\n"
#~ "        print(\"New dog!\")"
#~ msgstr ""
#~ "# Correct:\n"
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        self.age = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.weight = 0\n"
#~ "        print(\"New dog!\")"

#~ msgid ""
#~ "A constructor can be used for "
#~ "initializing and setting data for the"
#~ " object. The example Dog class above"
#~ " still allows the name attribute to"
#~ " be left blank after the creation "
#~ "of the dog object. How do we "
#~ "keep this from happening? Many objects"
#~ " need to have values right when "
#~ "they are created. The constructor "
#~ "function can be used to make this"
#~ " happen. See the code below:"
#~ msgstr ""
#~ "Ein Konstruktor kann zum Initialisieren "
#~ "und Festlegen von Daten für das "
#~ "Objekt verwendet werden. In der obigen"
#~ " Beispielklasse ``Dog`` kann das Attribut"
#~ " ``name`` nach der Erstellung des "
#~ "Hundeobjekts weiterhin leer gelassen werden."
#~ " Wie verhindern wir das? Viele "
#~ "Objekte müssen zum Zeitpunkt der "
#~ "Erstellung über Werte verfügen. Die "
#~ "Konstruktorfunktion kann verwendet werden, um"
#~ " dies zu erreichen. Siehe den Code"
#~ " unten:"

#~ msgid "Constructor that takes in data to initialize the class"
#~ msgstr "Konstruktor, der Daten übernimmt um das Exemplar zu initialisieren"

#~ msgid ""
#~ "class Dog():\n"
#~ "\n"
#~ "    def __init__(self, new_name):\n"
#~ "        \"\"\" Constructor. \"\"\"\n"
#~ "        self.name = new_name\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog(\"Spot\")\n"
#~ "\n"
#~ "    # Print the name to verify it was set\n"
#~ "    print(my_dog.name)\n"
#~ "\n"
#~ "    # This line will give an error because\n"
#~ "    # a name is not passed in.\n"
#~ "    her_dog = Dog()\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Dog():\n"
#~ "\n"
#~ "    def __init__(self, new_name):\n"
#~ "        \"\"\" Constructor. \"\"\"\n"
#~ "        self.name = new_name\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog(\"Spot\")\n"
#~ "\n"
#~ "    # Print the name to verify it was set\n"
#~ "    print(my_dog.name)\n"
#~ "\n"
#~ "    # This line will give an error because\n"
#~ "    # a name is not passed in.\n"
#~ "    her_dog = Dog()\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "On line 3 the constructor function "
#~ "now has an additional parameter named"
#~ " ``new_name``. The value of this "
#~ "parameter is used to set the name"
#~ " attribute in the ``Dog`` class on"
#~ " line 8. It is no longer "
#~ "possible to create a ``Dog`` class "
#~ "without a name. The code on line"
#~ " 15 tries this. It will cause a"
#~ " Python error and it will not "
#~ "run. A common mistake is to name"
#~ " the parameter of the ``__init__`` "
#~ "function the same as the attribute "
#~ "and assume that the values will "
#~ "automatically synchronize. This does not "
#~ "happen."
#~ msgstr ""
#~ "In Zeile 3 hat die Konstruktorfunktion"
#~ " jetzt einen zusätzlichen Parameter mit "
#~ "dem Namen ``new_name``. Der Wert dieses"
#~ " Parameters wird verwendet, um das "
#~ "Attribut ``name`` in der Klasse ``Dog``"
#~ " in Zeile 8 festzulegen. Es ist "
#~ "nicht mehr möglich, eine Klasse ``Dog``"
#~ " ohne Namen zu erstellen. Der Code"
#~ " in Zeile 15 versucht dies. Er "
#~ "wird einen Python-Fehler verursachen und"
#~ " nicht ausgeführt. Ein häufiger Fehler "
#~ "besteht darin, den Parameter der "
#~ "Funktion ``__init__`` mit dem Attribut "
#~ "zu benennen und anzunehmen, dass die "
#~ "Werte automatisch synchronisiert werden. Das"
#~ " passiert nicht."

#~ msgid "Should method names begin with an upper or lower case letter?"
#~ msgstr "Sollten Methodennamen mit einem Groß- oder Kleinbuchstaben beginnen?"

#~ msgid "Should attribute names begin with an upper or lower case letter?"
#~ msgstr "Sollten Attributnamen mit einem Groß- oder Kleinbuchstaben beginnen?"

#~ msgid "Which should be listed first in a class, attributes or methods?"
#~ msgstr ""
#~ "Was sollte zuerst in einer Klasse "
#~ "aufgeführt werden, Attribute oder Methoden?"

#~ msgid "What are other names for a reference?"
#~ msgstr "Welche anderen Bezeichnungen gibt es für \"Referenz\"?"

#~ msgid ""
#~ "Create a class called Star that "
#~ "will print out \"A star is born!\""
#~ " every time it is created."
#~ msgstr ""
#~ "Erstelle eine Klasse mit dem Namen "
#~ "Star, die \"Ein Stern ist geboren!\" "
#~ "jedes Mal ausgibt, wenn ein Exemplar "
#~ "erzeugt wird."

#~ msgid ""
#~ "Create a class called Monster with "
#~ "attributes for health and a name. "
#~ "Add a constructor to the class "
#~ "that sets the health and name of"
#~ " the object with data passed in "
#~ "as parameters."
#~ msgstr ""
#~ "Erstelle eine Klasse namens Monster mit"
#~ " Attributen für Gesundheit und Namen. "
#~ "Füge der Klasse einen Konstruktor hinzu,"
#~ " der den Zustand und den Namen "
#~ "des Objekts mit den als Parameter "
#~ "übergebenen Daten festlegt."

#~ msgid "Inheritance"
#~ msgstr "Vererbung"

#~ msgid ""
#~ "Another powerful feature of using "
#~ "classes and objects is the ability "
#~ "to make use of *inheritance*. It "
#~ "is possible to create a class and"
#~ " inherit all of the attributes and"
#~ " methods of a *parent class*."
#~ msgstr ""
#~ "Ein weiteres leistungsfähiges Merkmal der "
#~ "Verwendung von Klassen und Objekten ist"
#~ " die Möglichkeit, *Vererbung* zu nutzen."
#~ " Es ist möglich, eine Klasse zu "
#~ "erstellen und alle Attribute und "
#~ "Methoden einer *Elternklasse* zu erben."

#~ msgid ""
#~ "For example, a program may create "
#~ "a class called ``Boat`` which has "
#~ "all the attributes needed to represent"
#~ " a boat in a game:"
#~ msgstr ""
#~ "Zum Beispiel kann ein Programm eine "
#~ "Klasse namens ``Boat`` erstellen, die "
#~ "alle Attribute besitzt, die benötigt "
#~ "werden, um ein Boot in einem Spiel"
#~ " darzustellen:"

#~ msgid "Class definition for a boat"
#~ msgstr "Klassendefinition eines Boots"

#~ msgid ""
#~ "class Boat():\n"
#~ "    def __init__(self):\n"
#~ "        self.tonnage = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.is_docked = True\n"
#~ "\n"
#~ "    def dock(self):\n"
#~ "        if self.is_docked:\n"
#~ "            print(\"You are already docked.\")\n"
#~ "        else:\n"
#~ "            self.is_docked = True\n"
#~ "            print(\"Docking\")\n"
#~ "\n"
#~ "    def undock(self):\n"
#~ "        if not self.is_docked:\n"
#~ "            print(\"You aren't docked.\")\n"
#~ "        else:\n"
#~ "            self.is_docked = False\n"
#~ "            print(\"Undocking\")"
#~ msgstr ""
#~ "class Boat():\n"
#~ "    def __init__(self):\n"
#~ "        self.tonnage = 0\n"
#~ "        self.name = \"\"\n"
#~ "        self.is_docked = True\n"
#~ "\n"
#~ "    def dock(self):\n"
#~ "        if self.is_docked:\n"
#~ "            print(\"You are already docked.\")\n"
#~ "        else:\n"
#~ "            self.is_docked = True\n"
#~ "            print(\"Docking\")\n"
#~ "\n"
#~ "    def undock(self):\n"
#~ "        if not self.is_docked:\n"
#~ "            print(\"You aren't docked.\")\n"
#~ "        else:\n"
#~ "            self.is_docked = False\n"
#~ "            print(\"Undocking\")"

#~ msgid "To test out our code:"
#~ msgstr "So testen wir unseren Code:"

#~ msgid "Floating our boat"
#~ msgstr "Unser Boot schwimmen lassen"

#~ msgid ""
#~ "b = Boat()\n"
#~ "\n"
#~ "b.dock()\n"
#~ "b.undock()\n"
#~ "b.undock()\n"
#~ "b.dock()\n"
#~ "b.dock()"
#~ msgstr ""
#~ "b = Boat()\n"
#~ "\n"
#~ "b.dock()\n"
#~ "b.undock()\n"
#~ "b.undock()\n"
#~ "b.dock()\n"
#~ "b.dock()"

#~ msgid "The output:"
#~ msgstr "Die Ausgabe:"

#~ msgid ""
#~ "You are already docked.\n"
#~ "Undocking\n"
#~ "You aren't docked.\n"
#~ "Docking\n"
#~ "You are already docked."
#~ msgstr ""
#~ "You are already docked.\n"
#~ "Undocking\n"
#~ "You aren't docked.\n"
#~ "Docking\n"
#~ "You are already docked."

#~ msgid ""
#~ "(If you watch the video for this"
#~ " section of the class, you'll note"
#~ " that the \"Boat\" class in the "
#~ "video doesn't actually run. The code "
#~ "above has been corrected but I "
#~ "haven't fixed the video. Use this "
#~ "as a reminder, no matter how "
#~ "simple the code and how experienced "
#~ "the developer, test your code before "
#~ "you deliver it!)"
#~ msgstr ""
#~ "(Wenn du dir das Video für diesen"
#~ " Abschnitt des Kurses ansiehst, wirst "
#~ "du feststellen, dass die \"Boot\" "
#~ "-Klasse im Video nicht tatsächlich "
#~ "ausgeführt wird. Der obige Code wurde"
#~ " korrigiert, aber ich habe das Video"
#~ " nicht repariert. Verwende dies als "
#~ "Warnung, egal wie einfach der Code "
#~ "ist und wie erfahren der Entwickler "
#~ "ist, testen Sie Ihren Code, bevor "
#~ "du ihn auslieferst!)"

#~ msgid ""
#~ "Our program also needs a submarine. "
#~ "Our submarine can do everything a "
#~ "boat can, plus we need a command"
#~ " for ``submerge``. Without inheritance we"
#~ " have two options."
#~ msgstr ""
#~ "Unser Programm braucht auch ein U-Boot."
#~ " Unser U-Boot kann alles, was ein "
#~ "Boot kann, und wir brauchen ein "
#~ "Kommando für ``submerge`` (tauchen). Ohne "
#~ "Vererbung haben wir zwei Möglichkeiten."

#~ msgid ""
#~ "One, add the ``submerge()`` command to"
#~ " our boat. This isn't a great "
#~ "idea because we don't want to give"
#~ " the impression that our boats "
#~ "normally submerge."
#~ msgstr ""
#~ "Erstens, füge unserem Boot die Anweisung"
#~ " ``submerge`` hinzu. Dies ist keine "
#~ "gute Idee, da wir nicht den "
#~ "Eindruck erwecken möchten, dass unsere "
#~ "Boote normalerweise unter Wasser sind."

#~ msgid ""
#~ "Two, we could create a copy of "
#~ "the ``Boat`` class and call it "
#~ "``Submarine``. In this class we'd add"
#~ " the ``submerge()`` command. This is "
#~ "easy at first, but things become "
#~ "harder if we change the ``Boat`` "
#~ "class. A programmer would need to "
#~ "remember that we'd need to change "
#~ "not only the ``Boat`` class, but "
#~ "also make the same changes to the"
#~ " ``Submarine`` class. Keeping this code "
#~ "synchronized is time consuming and "
#~ "error-prone."
#~ msgstr ""
#~ "Zweitens könnten wir eine Kopie der "
#~ "Klasse ``Boat`` erstellen und sie "
#~ "``Submarine`` nennen. In dieser Klasse "
#~ "würden wir die Anweisung ``submerge`` "
#~ "hinzufügen. Das ist zunächst einfach, "
#~ "aber es wird schwieriger, wenn wir "
#~ "die Bootsklasse wechseln. Ein Programmierer"
#~ " müsste sich daran erinnern, dass wir"
#~ " nicht nur die Klasse ``Boat`` ändern"
#~ " müssen, sondern auch die Klasse "
#~ "``Submarine``. Das Synchronisieren dieses "
#~ "Codes ist zeitaufwändig und fehleranfällig."

#~ msgid ""
#~ "Luckily, there is a better way. "
#~ "Our program can create *child classes*"
#~ " that will inherit all the attributes"
#~ " and methods of the *parent class*."
#~ " The child classes may then add "
#~ "fields and methods that correspond to"
#~ " their needs. For example:"
#~ msgstr ""
#~ "Zum Glück gibt es einen besseren "
#~ "Weg. Unser Programm kann *Kindklassen* "
#~ "erstellen, die alle Attribute und "
#~ "Methoden der *Elternklasse* erben. Die "
#~ "Kindklassen können dann Attribute und "
#~ "Methoden hinzufügen, die ihren Anforderungen"
#~ " entsprechen. Zum Beispiel:"

#~ msgid ""
#~ "class Submarine(Boat):\n"
#~ "    def submerge(self):\n"
#~ "        print(\"Submerge!\")"
#~ msgstr ""
#~ "class Submarine(Boat):\n"
#~ "    def submerge(self):\n"
#~ "        print(\"Submerge!\")"

#~ msgid ""
#~ "Line 1 is the important part. Just"
#~ " by putting ``Boat`` in between the"
#~ " parentheses during the class declaration,"
#~ " we have automatically picked up "
#~ "every attribute and method that is "
#~ "in the Boat class. If we update"
#~ " ``Boat``, then the child class "
#~ "``Submarine`` will automatically get these "
#~ "updates. Inheritance is that easy!"
#~ msgstr ""
#~ "Zeile 1 ist der wichtige Teil. Nur"
#~ " dadurch, dass wir ``Boat`` während "
#~ "der Klassendeklaration in die Klammern "
#~ "geschrieben haben, haben wir jedes "
#~ "Attribut und jede Methode in der "
#~ "Klasse ``Boat`` automatisch aufgenommen. Wenn"
#~ " wir ``Boat`` aktualisieren, erhält die "
#~ "Kindklasse ``Submarine`` diese Änderungen "
#~ "automatisch. Vererbung ist so einfach!"

#~ msgid "The next code example is diagrammed out in the figure below."
#~ msgstr "Das nächste Codebeispiel wird in der Abbildung unten dargestellt."

#~ msgid "Person, Employee, Customer Classes Examples"
#~ msgstr "Beispiel Person-, Mitarbeiter- und Kunden-Klassen"

#~ msgid ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "\n"
#~ "class Employee(Person):\n"
#~ "    def __init__(self):\n"
#~ "        # Call the parent/super class constructor first\n"
#~ "        super().__init__()\n"
#~ "\n"
#~ "        # Now set up our variables\n"
#~ "        self.job_title = \"\"\n"
#~ "\n"
#~ "class Customer(Person):\n"
#~ "    def __init__(self):\n"
#~ "        super().__init__()\n"
#~ "        self.email = \"\"\n"
#~ "\n"
#~ "def main():\n"
#~ "    john_smith = Person()\n"
#~ "    john_smith.name = \"John Smith\"\n"
#~ "\n"
#~ "    jane_employee = Employee()\n"
#~ "    jane_employee.name = \"Jane Employee\"\n"
#~ "    jane_employee.job_title = \"Web Developer\"\n"
#~ "\n"
#~ "    bob_customer = Customer()\n"
#~ "    bob_customer.name = \"Bob Customer\"\n"
#~ "    bob_customer.email = \"send_me@spam.com\"\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "\n"
#~ "class Employee(Person):\n"
#~ "    def __init__(self):\n"
#~ "        # Call the parent/super class constructor first\n"
#~ "        super().__init__()\n"
#~ "\n"
#~ "        # Now set up our variables\n"
#~ "        self.job_title = \"\"\n"
#~ "\n"
#~ "class Customer(Person):\n"
#~ "    def __init__(self):\n"
#~ "        super().__init__()\n"
#~ "        self.email = \"\"\n"
#~ "\n"
#~ "def main():\n"
#~ "    john_smith = Person()\n"
#~ "    john_smith.name = \"John Smith\"\n"
#~ "\n"
#~ "    jane_employee = Employee()\n"
#~ "    jane_employee.name = \"Jane Employee\"\n"
#~ "    jane_employee.job_title = \"Web Developer\"\n"
#~ "\n"
#~ "    bob_customer = Customer()\n"
#~ "    bob_customer.name = \"Bob Customer\"\n"
#~ "    bob_customer.email = \"send_me@spam.com\"\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "By placing ``Person`` between the "
#~ "parentheses on lines 5 and 13, the"
#~ " programmer has told the computer "
#~ "that Person is a parent class to"
#~ " both ``Employee`` and ``Customer``. This"
#~ " allows the program to set the "
#~ "name attribute on lines 19 and 22."
#~ msgstr ""
#~ "Durch das Platzieren von ``Person`` "
#~ "zwischen den Klammern in den Zeilen "
#~ "5 und 13 hat der Programmierer dem"
#~ " Computer mitgeteilt, dass ``Person`` eine"
#~ " Elternklasse ist, und zwar sowohl "
#~ "für ``Employee`` als auch ``Customer``. "
#~ "Dadurch kann das Programm das Attribut"
#~ " ``name`` in den Zeilen 19 und "
#~ "22 festlegen."

#~ msgid ""
#~ "Methods are also inherited. Any method"
#~ " the parent has, the child class "
#~ "will have too. But what if we "
#~ "have a method in both the child"
#~ " and parent class?"
#~ msgstr ""
#~ "Methoden werden ebenfalls vererbt. Jede "
#~ "Methode, die die Elternklasse hat, wird"
#~ " auch die Kindklasse haben. Aber was"
#~ " ist, wenn wir sowohl in der "
#~ "Kind- als auch in der Elternklasse "
#~ "eine Methode haben, die den gleichen "
#~ "Namen hat?"

#~ msgid ""
#~ "We have two options. We can run"
#~ " them both with ``super()`` keyword. "
#~ "Using ``super()`` followed by a dot "
#~ "operator, and then finally a method "
#~ "name allows you to call the "
#~ "parent's version of the method."
#~ msgstr ""
#~ "Wir haben zwei Möglichkeiten. Wir können"
#~ " die Methode der Elternklasse dem "
#~ "Schlüsselwort ``super`` in der Methode "
#~ "der Kindklasse aufrufen. Mit ``super`` "
#~ "gefolgt von einem Punktoperator und "
#~ "schließlich einem Methodennamen kann man "
#~ "die Methode der Elternklasse aufrufen."

#~ msgid ""
#~ "The code above shows the first "
#~ "option using ``super`` where we run "
#~ "not only the child constructor but "
#~ "also the parent constructor."
#~ msgstr ""
#~ "Der obige Code zeigt die erste "
#~ "Option mit ``super``, bei der wir "
#~ "nicht nur den Konstruktor der "
#~ "Kindklasse, sondern auch den Konstruktor "
#~ "der Elternklasse ausführen."

#~ msgid ""
#~ "If you are writing a method for"
#~ " a child and want to call a "
#~ "parent method, normally it will be "
#~ "the first statement in the child "
#~ "method. Notice how it is in the"
#~ " example above."
#~ msgstr ""
#~ "Wenn Sie eine Methode für eine "
#~ "Kindklasse schreiben und eine Methode "
#~ "der Elternklasse aufrufen möchten, ist "
#~ "dies normalerweise die erste Anweisung "
#~ "in der untergeordneten Methode. Beachten "
#~ "Sie, wie es im obigen Beispiel "
#~ "ist."

#~ msgid ""
#~ "All constructors should call the parent"
#~ " constructor because then you'd have "
#~ "a child without a parent and that"
#~ " is just sad. In fact, some "
#~ "languages force this rule, but Python"
#~ " doesn't."
#~ msgstr ""
#~ "Alle Konstruktoren sollten den Konstruktor "
#~ "der Elternklasse aufrufen, da man sonst"
#~ " ein Kind ohne Eltern hätte, und "
#~ "das ist nur traurig. Einige Sprachen "
#~ "erzwingen diese Regel, Python jedoch "
#~ "nicht."

#~ msgid ""
#~ "The second option? Methods may be "
#~ "overridden by a child class to "
#~ "provide different functionality. The example"
#~ " below shows both options. The "
#~ "``Employee.report`` overrides the ``Person.report``"
#~ " because it never calls and runs "
#~ "the parent ``report`` method. The "
#~ "``Customer`` report does call the parent"
#~ " and the report method in "
#~ "``Customer`` adds to the ``Person`` "
#~ "functionality."
#~ msgstr ""
#~ "Die zweite Möglichkeit? Methoden können "
#~ "von einer Kindklasse überschrieben werden, "
#~ "um andere Funktionen bereitzustellen. Das "
#~ "folgende Beispiel zeigt beide Optionen. "
#~ "Der ``Employee.report`` überschreibt den "
#~ "``Person.report``, da er niemals die "
#~ "übergeordnete ``report``-Methode aufruft und "
#~ "ausführt. Der Bericht ``Kunde`` ruft das"
#~ " übergeordnete Element auf, und die "
#~ "Berichtsmethode in ``Kunde`` erweitert die "
#~ "Funktionalität von ``Person``."

#~ msgid ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "\n"
#~ "    def report(self):\n"
#~ "        # Basic report\n"
#~ "        print(\"Report for\", self.name)\n"
#~ "\n"
#~ "class Employee(Person):\n"
#~ "    def __init__(self):\n"
#~ "        # Call the parent/super class constructor first\n"
#~ "        super().__init__()\n"
#~ "\n"
#~ "        # Now set up our variables\n"
#~ "        self.job_title = \"\"\n"
#~ "\n"
#~ "    def report(self):\n"
#~ "        # Here we override report and just do this:\n"
#~ "        print(\"Employee report for\", self.name)\n"
#~ "\n"
#~ "class Customer(Person):\n"
#~ "    def __init__(self):\n"
#~ "        super().__init__()\n"
#~ "        self.email = \"\"\n"
#~ "\n"
#~ "    def report(self):\n"
#~ "        # Run the parent report:\n"
#~ "        super().report()\n"
#~ "        # Now add our own stuff to the end so we do both\n"
#~ "        print(\"Customer e-mail:\", self.email)\n"
#~ "\n"
#~ "def main():\n"
#~ "    john_smith = Person()\n"
#~ "    john_smith.name = \"John Smith\"\n"
#~ "\n"
#~ "    jane_employee = Employee()\n"
#~ "    jane_employee.name = \"Jane Employee\"\n"
#~ "    jane_employee.job_title = \"Web Developer\"\n"
#~ "\n"
#~ "    bob_customer = Customer()\n"
#~ "    bob_customer.name = \"Bob Customer\"\n"
#~ "    bob_customer.email = \"send_me@spam.com\"\n"
#~ "\n"
#~ "    john_smith.report()\n"
#~ "    jane_employee.report()\n"
#~ "    bob_customer.report()\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Person():\n"
#~ "    def __init__(self):\n"
#~ "        self.name = \"\"\n"
#~ "\n"
#~ "    def report(self):\n"
#~ "        # Basic report\n"
#~ "        print(\"Report for\", self.name)\n"
#~ "\n"
#~ "class Employee(Person):\n"
#~ "    def __init__(self):\n"
#~ "        # Call the parent/super class constructor first\n"
#~ "        super().__init__()\n"
#~ "\n"
#~ "        # Now set up our variables\n"
#~ "        self.job_title = \"\"\n"
#~ "\n"
#~ "    def report(self):\n"
#~ "        # Here we override report and just do this:\n"
#~ "        print(\"Employee report for\", self.name)\n"
#~ "\n"
#~ "class Customer(Person):\n"
#~ "    def __init__(self):\n"
#~ "        super().__init__()\n"
#~ "        self.email = \"\"\n"
#~ "\n"
#~ "    def report(self):\n"
#~ "        # Run the parent report:\n"
#~ "        super().report()\n"
#~ "        # Now add our own stuff to the end so we do both\n"
#~ "        print(\"Customer e-mail:\", self.email)\n"
#~ "\n"
#~ "def main():\n"
#~ "    john_smith = Person()\n"
#~ "    john_smith.name = \"John Smith\"\n"
#~ "\n"
#~ "    jane_employee = Employee()\n"
#~ "    jane_employee.name = \"Jane Employee\"\n"
#~ "    jane_employee.job_title = \"Web Developer\"\n"
#~ "\n"
#~ "    bob_customer = Customer()\n"
#~ "    bob_customer.name = \"Bob Customer\"\n"
#~ "    bob_customer.email = \"send_me@spam.com\"\n"
#~ "\n"
#~ "    john_smith.report()\n"
#~ "    jane_employee.report()\n"
#~ "    bob_customer.report()\n"
#~ "\n"
#~ "main()"

#~ msgid "Is-A and Has-A Relationships"
#~ msgstr "Ist-Ein- und Hat-Ein-Beziehungen"

#~ msgid ""
#~ "Classes have two main types of "
#~ "relationships. They are \"is a\" and "
#~ "\"has a\" relationships."
#~ msgstr ""
#~ "Es gibt zwei Arten von Beziehungen "
#~ "zwischen Klassen. Das sind die \"ist "
#~ "ein\" (englisch \"is a\") und \"hat "
#~ "ein\" (\"has a\")."

#~ msgid ""
#~ "A parent class should always be a"
#~ " more general, abstract version of "
#~ "the child class. This type of "
#~ "child to parent relationship is called"
#~ " an *is a* relationship. For example,"
#~ " a parent class ``Animal`` could have"
#~ " a child class ``Dog``. The dog "
#~ "*is an* animal. The ``Dog`` class "
#~ "could have a child class Poodle. "
#~ "The poodle *is a* dog, and *is "
#~ "an* animal."
#~ msgstr ""
#~ "Eine Elternklasse sollte immer eine "
#~ "allgemeinere, abstraktere Version der "
#~ "Kindklasse sein. Diese Art der Beziehung"
#~ " zwischen Kind und Eltern wird als"
#~ " *Ist-Ein-Beziehung* bezeichnet. Zum "
#~ "Beispiel könnte eine Elternklasse ``Animal``"
#~ " eine Kindklasse ``Dog`` haben. Der "
#~ "Hund *ist ein* Tier. Die Klasse "
#~ "``Hund`` könnte eine Kinderklasse ``Poodle``"
#~ " (Pudel) haben. Der Pudel *ist ein*"
#~ " Hund und *ist ein* Tier."

#~ msgid ""
#~ "It does not work the other way!"
#~ " A dolphin *is a* mammal, but a"
#~ " mammal is not always a dolphin. "
#~ "So the class ``Dolphin`` should never"
#~ " be a parent to a class "
#~ "``Mammal``."
#~ msgstr ""
#~ "Anders herum funktioniert es nicht! Ein"
#~ " Delphin ist ein Säugetier, aber ein"
#~ " Säugetier ist nicht immer ein "
#~ "Delphin. Daher sollte die Klasse "
#~ "``Dolphin`` niemals eine Elternklasse von "
#~ "``Mammal`` sein."

#~ msgid ""
#~ "Unrelated items that do not pass "
#~ "the *is a* test should not form"
#~ " parent/child relationships. For example, a"
#~ " class ``Table`` should not be a "
#~ "parent to a class ``Chair`` because "
#~ "a chair is not a table."
#~ msgstr ""
#~ "Nicht verwandte Elemente, die den Test"
#~ " *ist ein* nicht bestehen, sollten "
#~ "keine Eltern-Kind-Beziehungen eingehen. "
#~ "Zum Beispiel sollte eine Klasse "
#~ "``Table`` kein Elternteil einer Klasse "
#~ "``Chair`` sein, da ein Stuhl kein "
#~ "Tisch ist."

#~ msgid ""
#~ "The other type of relationship is "
#~ "the *has a* relationship. These "
#~ "relationships are implemented in code by"
#~ " class attributes. A dog has a "
#~ "name, and so the ``Dog`` class has"
#~ " an attribute for name. Likewise a"
#~ " person could have a dog, and "
#~ "that would be implemented by having "
#~ "the Person class have an attribute "
#~ "for ``Dog``. The ``Person`` class would"
#~ " not derive from ``Dog`` because that"
#~ " would be some kind of insult."
#~ msgstr ""
#~ "Die andere Art der Beziehung ist "
#~ "die *Hat-Ein-Beziehung*. Diese "
#~ "Beziehungen werden durch Attribute im "
#~ "Code implementiert. Ein Hund hat einen"
#~ " Namen, und so hat die Klasse "
#~ "``Dog`` ein Attribut ``name``. Ebenso "
#~ "könnte eine Person einen Hund haben, "
#~ "und dies würde implementiert, indem die"
#~ " Person-Klasse ein Attribut für "
#~ "``Dog`` hat. Die Klasse ``Person`` würde"
#~ " sich nicht von ``Dog`` ableiten, "
#~ "weil das eine Art Beleidigung wäre."

#~ msgid "Looking at the prior code example we can see:"
#~ msgstr "Wenn wir uns das vorherige Codebeispiel ansehen, sehen wir:"

#~ msgid "Employee is a person."
#~ msgstr "Mitarbeiter ist eine Person."

#~ msgid "Customer is a person."
#~ msgstr "Kunde ist eine Person"

#~ msgid "Person has a name."
#~ msgstr "Eine Person hat einen Namen."

#~ msgid "Employee has a job title."
#~ msgstr "Ein Mitarbeiter hat eine Berufsbezeichnung."

#~ msgid "Customer has an e-mail."
#~ msgstr "Ein Kunde hat eine E-Mail-Adresse."

#~ msgid "Static Variables vs. Instance Variables"
#~ msgstr "Klassen- und Objektvariablen"

#~ msgid ""
#~ "The difference between static and "
#~ "instance variables is confusing. Thankfully"
#~ " it isn't necessary to completely "
#~ "understand the difference right now. But"
#~ " if you stick with programming, it"
#~ " will be. Therefore we will briefly"
#~ " introduce it here."
#~ msgstr ""
#~ "Der Unterschied zwischen Klassen- und "
#~ "Objektvariablen ist verwirrend. Zum Glück "
#~ "ist es nicht notwendig, den Unterschied"
#~ " jetzt vollständig zu verstehen. Aber "
#~ "wenn du bei der Programmierung bleibst,"
#~ " wirst du den Unterschied verstehen "
#~ "(müssen). Deshalb werden wir ihn hier"
#~ " kurz vorstellen."

#~ msgid ""
#~ "There are also some oddities with "
#~ "Python that kept me confused the "
#~ "first several years I've made this "
#~ "book available. So you might see "
#~ "older videos and examples where I "
#~ "get it wrong."
#~ msgstr ""
#~ "Es gibt auch einige Kuriositäten bei "
#~ "Python, die mich in den ersten "
#~ "Jahren, in denen ich dieses Buch "
#~ "zur Verfügung gestellt habe, verwirrt "
#~ "haben. Du siehst also möglicherweise "
#~ "ältere Videos und Beispiele, bei denen"
#~ " ich etwas falsch mache."

#~ msgid ""
#~ "An *instance variable* is the type "
#~ "of class variable we've used so "
#~ "far. Each instance of the class "
#~ "gets its own value. For example, "
#~ "in a room full of people each "
#~ "person will have their own age. "
#~ "Some of the ages may be the "
#~ "same, but we still need to track"
#~ " each age individually."
#~ msgstr ""
#~ "Eine *Objektvariable* ist die Art von"
#~ " Attributen, die wir bisher verwendet "
#~ "haben. Jedes Exemplar der Klasse erhält"
#~ " einen eigenen Wert. In einem Raum"
#~ " voller Menschen hat zum Beispiel "
#~ "jede Person ihr eigenes Alter. Einige"
#~ " mögen gleich alt sein, aber wir "
#~ "müssen jedes Alter einzeln speichern."

#~ msgid ""
#~ "With instance variables, we can't just"
#~ " say \"age\" with a room full "
#~ "of people. We need to specify "
#~ "*whose* age we are talking about. "
#~ "Also, if there are no people in"
#~ " the room, then referring to an "
#~ "age when there are no people to"
#~ " have an age makes no sense."
#~ msgstr ""
#~ "Bei Objektvariablen können wir bei einem"
#~ " Raum voller Menschen nicht einfach "
#~ "\"Alter\" sagen. Wir müssen angeben, "
#~ "über *wessen* Alter wir sprechen. "
#~ "Befinden sich keine Personen im Raum,"
#~ " ist es sinnlos, sich auf ihr "
#~ "Alter zu beziehen."

#~ msgid ""
#~ "With *static variables* the value is "
#~ "the same for every single instance "
#~ "of the class. Even if there are"
#~ " no instances, there still is a "
#~ "value for a static variable. For "
#~ "example, we might have a ``count`` "
#~ "static variable for the number of "
#~ "``Human`` classes in existence. No "
#~ "humans? The value is zero, but the"
#~ " count variable still exists."
#~ msgstr ""
#~ "Bei *Klassenvariablen* ist der Wert für"
#~ " jedes einzelne Exemplar der Klasse "
#~ "gleich. Auch wenn es keine Exemplare "
#~ "gibt, gibt es immer noch einen "
#~ "Wert für eine Klassenvariable. Zum "
#~ "Beispiel könnten wir eine Klassenvariable "
#~ "``count`` für die Anzahl der "
#~ "existierenden ``Human``-Objekte haben. Keine "
#~ "Menschen? Der Wert ist Null, aber "
#~ "die Zählvariable ist noch vorhanden."

#~ msgid ""
#~ "In the example below, ``ClassA`` creates"
#~ " an instance variable. ``ClassB`` creates"
#~ " a static variable."
#~ msgstr ""
#~ "Im Beispiel unten erzeugt ``ClassA`` "
#~ "eine Objektvariable und ``ClassB`` eine "
#~ "Klassenvariable."

#~ msgid ""
#~ "# Example of an instance variable\n"
#~ "class ClassA():\n"
#~ "    def __init__(self):\n"
#~ "        self.y = 3\n"
#~ "\n"
#~ "# Example of a static variable\n"
#~ "class ClassB():\n"
#~ "    x = 7\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create class instances\n"
#~ "    a = ClassA()\n"
#~ "    b = ClassB()\n"
#~ "\n"
#~ "    # Two ways to print the static variable.\n"
#~ "    # The second way is the proper way to do it.\n"
#~ "    print(b.x)\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "    # One way to print an instance variable.\n"
#~ "    # The second generates an "
#~ "error, because we don't know what "
#~ "instance\n"
#~ "    # to reference.\n"
#~ "    print(a.y)\n"
#~ "    print(ClassA.y)\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "# Example of an instance variable\n"
#~ "class ClassA():\n"
#~ "    def __init__(self):\n"
#~ "        self.y = 3\n"
#~ "\n"
#~ "# Example of a static variable\n"
#~ "class ClassB():\n"
#~ "    x = 7\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create class instances\n"
#~ "    a = ClassA()\n"
#~ "    b = ClassB()\n"
#~ "\n"
#~ "    # Two ways to print the static variable.\n"
#~ "    # The second way is the proper way to do it.\n"
#~ "    print(b.x)\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "    # One way to print an instance variable.\n"
#~ "    # The second generates an "
#~ "error, because we don't know what "
#~ "instance\n"
#~ "    # to reference.\n"
#~ "    print(a.y)\n"
#~ "    print(ClassA.y)\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "In the example above, lines 16 and"
#~ " 17 print out the static variable."
#~ " Line 17 is the \"proper\" way "
#~ "to do so. Unlike before, we can"
#~ " refer to the class name when "
#~ "using static variables, rather than a"
#~ " variable that points to a particular"
#~ " instance. Because we are working "
#~ "with the class name, by looking at"
#~ " line 17 we instantly can tell "
#~ "we are working with a static "
#~ "variable. Line 16 could be either "
#~ "an instance or static variable. That "
#~ "confusion makes line 17 the better "
#~ "choice."
#~ msgstr ""
#~ "Im obigen Beispiel geben die Zeilen "
#~ "16 und 17 die Klassenvariable aus. "
#~ "Zeile 17 ist der \"richtige\" Weg, "
#~ "dies zu tun. Anders als zuvor "
#~ "können wir bei der Verwendung von "
#~ "Klassenvariablen auf den Klassennamen "
#~ "verweisen, anstatt auf eine Variable, "
#~ "die auf ein bestimmtes Objekt verweist."
#~ " Da wir mit dem Klassennamen "
#~ "arbeiten, können wir in Zeile 17 "
#~ "sofort erkennen, dass wir mit einer "
#~ "Klassenvariablen arbeiten. Zeile 16 kann "
#~ "entweder eine Objektvariable oder eine "
#~ "Klassenvariable sein. Diese Unklarheit macht"
#~ " Zeile 17 zur besseren Wahl."

#~ msgid ""
#~ "Line 22 prints out the instance "
#~ "variable, just like we've done in "
#~ "prior examples. Line 23 will generate"
#~ " an error because each instance of"
#~ " y is different (it is an "
#~ "instance variable after all) and we "
#~ "aren't telling the computer what "
#~ "instance of ``ClassA`` we are talking"
#~ " about."
#~ msgstr ""
#~ "Zeile 22 gibt die Objektvariable aus,"
#~ " genau wie in den vorherigen "
#~ "Beispielen. Zeile 23 erzeugt einen "
#~ "Fehler, weil jedes Exemplar von ``y``"
#~ " anders ist (es ist schließlich eine"
#~ " Objektvariable) und wir dem Rechner "
#~ "nicht sagen, um welches Exemplar von "
#~ "``ClassA`` es sich handelt."

#~ msgid "Instance Variables Hiding Static Variables"
#~ msgstr "Objektvariable verdecken Klassenvariablen"

#~ msgid ""
#~ "This is one \"feature\" of Python "
#~ "I dislike. It is possible to have"
#~ " a static variable, and an instance"
#~ " variable *with the same name*. Look"
#~ " at the example below:"
#~ msgstr ""
#~ "Dies ist eine Eigenschaft von Python,"
#~ " die ich nicht mag. Es ist "
#~ "möglich, eine Klassenvariable und eine "
#~ "Objektvariable *mit demselben Namen* zu "
#~ "haben. Schaue dir das folgende Beispiel"
#~ " an:"

#~ msgid ""
#~ "# Class with a static variable\n"
#~ "class ClassB():\n"
#~ "    x = 7\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create a class instance\n"
#~ "    b = ClassB()\n"
#~ "\n"
#~ "    # This prints 7\n"
#~ "    print(b.x)\n"
#~ "\n"
#~ "    # This also prints 7\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "    # Set x to a new value using the class name\n"
#~ "    ClassB.x = 8\n"
#~ "\n"
#~ "    # This also prints 8\n"
#~ "    print(b.x)\n"
#~ "\n"
#~ "    # This prints 8\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "    # Set x to a new value using the instance.\n"
#~ "    # Wait! Actually, it doesn't set x to a new value!\n"
#~ "    # It creates a brand new variable, x. This x\n"
#~ "    # is an instance variable. The static variable is\n"
#~ "    # also called x. But they are two different\n"
#~ "    # variables. This is super-confusing and is bad\n"
#~ "    # practice.\n"
#~ "    b.x = 9\n"
#~ "\n"
#~ "    # This prints 9\n"
#~ "    print(b.x)\n"
#~ "\n"
#~ "    # This prints 8. NOT 9!!!\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "# Class with a static variable\n"
#~ "class ClassB():\n"
#~ "    x = 7\n"
#~ "\n"
#~ "def main():\n"
#~ "    # Create a class instance\n"
#~ "    b = ClassB()\n"
#~ "\n"
#~ "    # This prints 7\n"
#~ "    print(b.x)\n"
#~ "\n"
#~ "    # This also prints 7\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "    # Set x to a new value using the class name\n"
#~ "    ClassB.x = 8\n"
#~ "\n"
#~ "    # This also prints 8\n"
#~ "    print(b.x)\n"
#~ "\n"
#~ "    # This prints 8\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "    # Set x to a new value using the instance.\n"
#~ "    # Wait! Actually, it doesn't set x to a new value!\n"
#~ "    # It creates a brand new variable, x. This x\n"
#~ "    # is an instance variable. The static variable is\n"
#~ "    # also called x. But they are two different\n"
#~ "    # variables. This is super-confusing and is bad\n"
#~ "    # practice.\n"
#~ "    b.x = 9\n"
#~ "\n"
#~ "    # This prints 9\n"
#~ "    print(b.x)\n"
#~ "\n"
#~ "    # This prints 8. NOT 9!!!\n"
#~ "    print(ClassB.x)\n"
#~ "\n"
#~ "main()"

#~ msgid ""
#~ "Allowing instance variables to hide "
#~ "static variable caused confusion for me"
#~ " for many years!"
#~ msgstr ""
#~ "Das Verbergen von Klassenvariablen durch "
#~ "Objektvariablen hat mich viele Jahre "
#~ "durcheinander gebracht!"

#~ msgid "Ein neuer Hund wird geworfen!"
#~ msgstr ""

#~ msgid ""
#~ "We need a variable that will point"
#~ " to our address. In this case, "
#~ "we've called it ``home_address``. Then "
#~ "we follow that with parentheses, which"
#~ " will \"magically\" call the ``__init__``"
#~ " method where we set up the "
#~ "fields/attributes for the class."
#~ msgstr ""

#~ msgid ""
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = \"\"\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog()"
#~ msgstr ""
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = \"\"\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog()"

#~ msgid ""
#~ "class Dog():\n"
#~ "    def __init__(self, new_name):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = new_name\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog()\n"
#~ "\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = \"\"\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog()"

#~ msgid ""
#~ "class Dog():\n"
#~ "    def __init__(self, new_name):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = new_name\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog(\"Fluffy\")\n"
#~ "\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = \"\"\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog()"

#~ msgid ""
#~ "class Dog():\n"
#~ "    def __init__(self, name):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = name\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog(\"Fluffy\")\n"
#~ "\n"
#~ "\n"
#~ "main()"
#~ msgstr ""
#~ "class Dog():\n"
#~ "    def __init__(self):\n"
#~ "        \"\"\" Constructor. Called when "
#~ "creating an object of this type. "
#~ "\"\"\"\n"
#~ "        self.name = \"\"\n"
#~ "        print(\"A new dog is born!\")\n"
#~ "\n"
#~ "\n"
#~ "def main():\n"
#~ "    # This creates the dog\n"
#~ "    my_dog = Dog()"

